[{"content":"操作系统设计 Cpt1 绪论 并发和并行 并发指同时有多个进程要活动，表示需求的同时到来，而并行指同时有多个进程正在活动，表示需求的同时执行。对于单核CPU而言，并发=并行。对于CPU的每一个核而言，所有进程都是串行执行的。\n进程运行图 示例：\nCpt2 操作系统的结构核硬件支持 处理机的态 也叫特权级，表示处于何种状态，正在执行哪类程序，至少有两种态：管态（S）和用户态（U）。管态表示操作系统执行管理程序时的状态，可以使用全部机器指令，所有资源和整个存储区。用户态表示用户程序执行时的状态，禁止使用特权指令，只能访问自己的存储区 。\n通过状态寄存器中的系统状态位区分，1位区分两态。用户态下超出权限将发生中断，变为管态处理事件。\n特权指令可以：修改机器状态、修改特殊寄存器、涉及外设的输入/输出。\n硬件中断 向量中断 中断源自己引导处理机进入中断服务程序的过程叫做向量中断，多见于低端嵌入式系统，检测方式是对于每一个中断类型设置一个中断向量，包含中断处理程序入口和处理器状态字。\n中断向量放置于中断向量表里，必须同步更新中断类型、中断处理程序和中断向量表才能添加新的中断。\n探询中断 将中断类型分为几个大类（极端情况下就是一类，即中断向量表退化为一个寄存器，存放总中断处理程序入口地址，直接跳转），按照大类设置中断向量表。\n软件中断 中断过程中需要保存和恢复现场，将用户态运行的状态（PC，SP，a0-a11等寄存器）存到主存中（trapframe），然后中断退出时从主存中读取状态并恢复。这些行为在中断处理程序进行，属于软件中断的部分。\n程序状态字寄存器用户存储目前的执行状况，包含当前指令、执行状况、处理机态、屏蔽中断等内容。\nCpt4 进程及进程管理 并发执行伪代码 进程状态 进程最少也需要有三种状态：运行、就绪、等待\n进程队列管理 进程原语 原语是原子的系统调用，无法被中断，包括进程创建、撤销、等待和唤醒。\ncreate { //申请空PCB结构 if(/*无空PCB结构*/) return /*错误码*/; //初始化PCB内容 //插入到就绪队列中 return /*新进程pid*/; } kill { //获取当前进程PCB //释放资源 //释放PCB块 //进程调度 } susp(chan) { //保存现场到PCB中 //插入到chan的等待队列中 //进程调度 } wakeup(chan) { //找到chan的等待队列 for(/*等待该事件的进程*/) { //进程移动到就绪队列 } } 锁 lock(w) { while(w == 1) { //保存现场到PCB中 //插入到w的等待队列 //进程调度 } w = 1; } unlock(w) { if(/*w的等待队列非空*/) { //将等待队首置于就绪队列中 } w = 0; } 信号灯 P(s) { s--; if(s \u0026lt; 0) { //保存现场到PCB中 //插入到s的等待队列中 //进程调度 } } V(s) { s++; if(s \u0026lt;= 0) { //将s的等待队首置于就绪队列中 } } 线程 线程是比进程更加小的概念，是进程执行中的一条路径，共享父进程的主存。\n实例 fork() fork()用于复制子进程，对于父进程返回子进程的pid，对于子进程，返回0。代码段可以被共享，需要分配并复制数据段和堆栈段。\nexec() exec()类函数用于加载一个可执行文件，用于取代当前进程，当前进程的所有原本内容都被废弃。\nwait(stat_addr) wait()函数用于父进程等待任何一个子进程退出，并返回子进程的pid，stat_addr用于获取子进程的退出码。\nCpt5 资源分配与调度 资源描述器/资源信息块 分配策略 FIFO 每次产生的新请求排在队尾，当资源可用时，选取请求队列的队首满足。\n优先调度 对每一个进程指定一个优先级，对每一个优先级安排一个就绪队列。请求时，将进程插入到对应的就绪队列中。\n移臂调度 在磁盘组中，柱面号决定是磁盘的同心圈中的哪一圈，盘面号决定是哪一个移动臂输出（每一面都有一个移动臂，所有移动臂指向面的同一个点），块号决定是圈中的哪一个点。编址的时候是（柱面号，盘面号，块号），移动成本是柱面\u0026gt;块\u0026gt;盘面。\n最短寻道时间优先算法(SSTF) 选择使当前移臂距离最短的请求，主要针对的是不同柱面号的请求调度。\n扫描算法(SCAN) 沿着当前臂的移动方向选择里目前柱面最近的柱面，当无候选柱面时，再改变移动方向。\n循环扫描算法(CSCAN) 磁头只做单向移动，比如从里向外，当到达最外被访问的柱面时，磁头返回到最里面的待访问柱面。\n旋转调度 旋转调度解决的是对于同一的柱面号，如何访问不同的块号，即移动臂选转。旋转调度希望能够选转最少的次数完成访问，因此在插入请求时会先按照块号排序。\n死锁 死锁产生的必要四要素是：\n互斥：资源一次只能由一个进程使用 不剥夺：资源只能由占有进程释放 部分分配：资源每次申请一部分资源，等待新资源时也占有已有资源 循环等待：存在循环链，每一个进程已获得的资源被下一个进程请求 安全状态 按照某种顺序，并发进程都能达到获得全部资源而顺序完成的队列。预防死锁是让每次分配都维持在安全态内，排除死锁是让系统重新回到安全态。\n解决方案 采用静态资源分配方法预防 采用动态分配，有空分配避免 检测死锁，设法修复 一旦发生就重启系统 有序资源分配法 对于每一类资源分配唯一的号码，在申请时必须按照编号依次申请，即为递增列表，比如1 输入机，2 磁带机，4 打印机。\n银行家算法 进程声明了对各类资源的最大需求量，仅当申请者可以在一定时间内无条件地归还申请的全部资源时，才能满足分配。也就是说，哪怕把该进程缺的所有资源分给它，也不会超过系统资源上限，那么才能分配。\nCpt6 处理机调度 作业调度算法性能衡量 调度算法 调度准则 优点 缺点 先来先服务 按作业到达先后顺序 算法简单，对长作业有利，实现公平。 对短作业不利；平均等待时间较长。 短作业优先 预估服务时间最短的优先 平均周转时间最短，系统吞吐量大。 对长作业不利；需预知服务时间，难以准确估算。 高响应比优先 响应比 Rp 最高的优先 综合考虑了等待和服务时间，平衡了长短作业。 每次调度前需重新计算所有作业响应比，增加开销。 进程调度 优先数调度算法 采用之前Cpt4的优先调度方式\n循环轮转调度 CPU空闲时取就绪队首分配时间片，用完时释放所有权。分为固定时间片和可变时间片，可变时间片根据实际进程数决定时间片长度。\n多级反馈队列调度 在优先级就绪队列的基础之上，优先级越低时间片越长。优先级根据进程存在的时间降低，第一次进入调度队列时进入优先级最高的队列，之后每次进入都降低一级。\n进程状态变迁图 Cpt7 主存管理 分区存储 分区大小不相等，根据分区进行动态地址映射，一般通过基址寄存器进行。系统会维护一个空闲区队列，表示主存中所有空闲的区，包含分区大小。\n名称 队列排序 优点 缺点 首次适应 按地址低地址 到高地址 高地址保留了大块空间。 导致低地址处留下一堆碎片。 最佳适应 按容量从小到大 尽量不浪费大空间。 剩下的空间往往太小，无法使用。 最坏适应 按容量从大到小 剩下的空间依然很大，足以容纳其他作业，不容易产生碎片。 后期无法申请大型空间。 页式存储 每个页的大小相等，动态申请动态映射。通过页表进行地址转换，页表项包含虚拟页号和物理页（块）号还有中断位（是否调入主存）。有一个寄存器存储了页表的地址，通过此基址加上虚拟地址中的虚拟页号查找到了物理页号，然后再转化为物理地址。\n为了减少查找的耗时，在缓存中使用相联存储器将页表的部分装入，称之为快表，每次先从快表中查找，如果找不到再去页表中找，并将对应的页表项送入快表。\n算法名称 淘汰核心准则 硬件支持/数据结构 淘汰执行过程 FIFO 淘汰进入内存时间最早的页面。 队列 ：按调入顺序链接页面。 始终淘汰位于队首的页面。新调入页面进入队尾。 LRU 淘汰距当前时间点最久未被访问的页面。 栈或 寄存器：需要硬件记录访问时间戳。 每次页面被访问，将其移动至栈顶。淘汰时，直接移除栈底页面。 近似 LRU 结合循环扫描与访问标记。 循环链表 + 访问位：每个页表项设一访问位。 指针循环扫描。若访问位为 1，则将其置 0 并跳过；若访问位为 0，则淘汰该页。 段/段页式存储 程序由若干个段组成，由编程时指定。通过段表来完成映射，段表项包括段号，长度和基址。\n若加入页式存储，将每个段分为若干个页，那么地址则分为了（段号，页号，偏移）。访问时第一次访问段表，得到段对应的页表，之后就和页式存储的访问逻辑一致了。此时的段表项包含段号、页表长度（页表项数目）、页表始地址。\nCpt8 设备管理 设备的独立性 使用逻辑设备名来使用设备而不是物理设备名，由操作系统指派和检测。\n缓冲 为了解决CPU的高速和I/O设备的低速不一致的问题，可以通过缓冲技术来解决。一般采用软件缓冲，在主存中分配一部分空间用于暂时的存储数据。\n在请求读的时候，首先分配一个空的缓冲区，然后将数据输入到缓冲区中。当需要使用的时候，从缓冲区中提取。只有当缓冲区为空的时候有需要从中获取信息的时候，才需要等待。\n在请求写的时候，首先分配一个空缓冲区，然后将数据输入到缓冲区，当缓冲区装满的时候，数据被输送到I/O设备上，并清空缓冲区。只有当缓冲区未空有需要向其中写入时，才需要等待。\n输入/输出控制 通信的方式可以通过特殊的I/O指令，也可以通过主存地址映射。\n控制方式 交换单位 控制逻辑与工作原理 中央处理器干预程度 优点 缺点 程序循环测试 字或字节 中央处理器通过程序指令不断读取设备控制器状态位。若设备未就绪，则中央处理器处于忙等状态。 极高：中央处理器完全受限于外部设备速度，全程参与状态查询。 硬件结构简单，不需要额外的控制逻辑。 资源利用率极低，中央处理器与外设无法并行工作。 中断驱动 字或字节 当外部设备准备就绪后向中央处理器发出中断请求，处理器保护现场并转入中断服务程序处理数据。 较高：仅在数据准备就绪时干预，但高频中断仍会占用大量处理时间。 实现了中央处理器与外部设备的并行工作。 处理大量数据时频繁产生中断，系统开销显著。 直接存储器存取 数据块 由专用控制器控制内存与外设直接交换数据，数据流不经过中央处理器寄存器。 中等：仅在数据块传输的起始时刻和结束时刻进行干预。 大幅提升了数据块传输效率，减轻了中央处理器的计算负担。 硬件结构较复杂，每个控制器通常仅能管理极少量设备。 字节多路通道 字节 通道在多个低速设备间通过时间片轮转实现分时并行，每次轮流传输一个字节。 极低：中央处理器仅发出启动指令，后续由通道程序自主控制。 可连接大量低速设备，并在逻辑上实现多设备同时运行。 传输效率受限于字节级交换，不适合连接高速外部设备。 选择通道 数据块 通道在一段时间内被一个高速设备独占，实现内存与外设间连续的数据块传输。 极低：中央处理器仅负责任务的初始调度与最终完成确认。 能够支持极高的数据传输速率，满足高速设备需求。 资源利用率不均，通道被独占时其他设备必须挂起等待。 数组多路通道 数据块 在多个高速设备间轮流分时传输数据块，利用设备寻址的时间空隙进行链路切换。 极低：中央处理器与通道之间实现了高度的独立性与并行性。 兼具高速传输能力与多设备并发能力，系统整体吞吐量最高。 硬件控制逻辑最为精密复杂，系统构建成本最高。 Cpt9 文件系统 逻辑记录和物理记录 文件是具有符号名的数据/记录的集合，逻辑文件是用户看到的文件视图，物理文件是信息在物理存储器上的存储方式。\n逻辑记录是文件按信息在逻辑上独立划分的单位，被视为一组连续的记录的集合。\n物理记录时连续信息所组成的一个区域，称为块，是数据交换的基本单位。\n逻辑结构 一般采用流式文件，是相关的有序字符的合集，文件长度就是所含字符数。流式文件无结构，可以直接建立映射。顺序存取和随机存取就是顺序访问和随机访问文件的内容。\n物理结构 将每一个磁道分为多个扇区（块），就是数据交换的最小单位。\n连续文件 文件放置的连续的块上，在文件目录中只需要存储文件第一个逻辑记录（第一个逻辑块）所在的磁盘块号和文件占用块大小即可。连续文件存取快，但是长度不易改变，适用于顺序访问。\n串联文件 每个物理块的最后一个（或第一个）字作为链接字，表示文件后继块的块号。而文件目录中只需要存储文件的首块号，块可以随机分布而不用连续存储。串联文件不适合随机存取，比较适合于顺序存取。\n也可以将链接表单独拿出来不放到块中，形成文件映照图。\n索引文件 仿照页表，采用文件索引表的形式对文件占用的块进行映射，文件目录中存储的是索引表的指针，而索引表项包含逻辑块号和物理块号。同时支持多级索引表，就像多级页表一样。\n存储空间管理 使用类似主存管理的方式，有空闲文件目录（空闲块号，空闲块个数）、空闲块链（下一个空闲块号）、位视图。\n文件目录 一般采用多级文件目录来处理重名和复杂结构，每一级目录都可以对应一个目录文件，而信息文件一定在树叶上。目录和文件一样，都具有唯一id和标识符。\n文件共享 存取权限及其验证 权限分为：\nE 允许执行但不能读 R 允许读 U 允许修改 W 允许修改和添加新内容 D 允许删除 C 允许修改文件属性，为文件拥有者所有 安全机制 实现方式 优点 缺点 访问控制矩阵 使用二维矩阵表示。行代表用户，列代表文件。交叉单元格记录该主体对该客体拥有的权限。 概念直观、逻辑清晰。能够完整地描述系统中所有主体与客体之间的权限关系。 在大型系统中，矩阵通常极度稀疏，导致存储空间极大浪费；维护与动态修改效率低下。 存取控制表 以文件为中心。为每个资源关联一个列表，记录所有允许访问该资源的用户及其对应的权限。 易于查阅和管理特定资源的访问情况。在删除资源时，关联的控制表可以一并销毁，管理便捷。 难以快速查询特定主体拥有的所有权限。当用户数量庞大时，列表可能变得过长。 用户权限表 以用户为中心。为每个用户关联一个权限清单，记录该用户被授权访问的所有资源及其操作权限。 易于查询和管理特定主体的权限集合。在用户离职或权限变更时，只需修改该用户对应的权限表即可，安全性响应快。 难以确定特定资源的授权分布情况。在回收某个特定资源的权限时，需遍历所有用户的权限表。 口令和密码 通过用户持有的私密信息进行身份鉴别。系统通常存储口令的单向哈希值，在登录时进行匹配比对。 实现成本极低，用户接受度高，是系统进入的第一道防线。不需要复杂的硬件支持。 存在弱口令风险，极易受到社会工程学、字典攻击或暴力破解。若存储文件被泄露且未加密处理，会导致大规模身份被冒用。 查找加速 可以使用建立当前目录（cwd）和链接技术来快速的访问。其中链接技术就是向文件树里面添加对于其他的目录表项的链接，类似于快捷方式。因此需要维护“连访属性”（指向文件还是目录表项）和“引用计数”，只用没有人引用了才能真正删除文件。\n在Linux中，硬链接会添加一个实际的索引节点，指向被链接的文件，多个目录表项可以指向一个文件。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/%E6%9D%82%E8%B0%88/os/","summary":"期末总结","title":"HUST操作系统设计复习总结"},{"content":"C# 更新记录 在此记录C#版本更新时带来的新特性，并给出C#版本和使用场景的对应关系。\nC# 8.0 可空引用类型 除了int?、float?这样的可空值类型，引入了string?这样的可空引用类型。但是由于引用变量本身就可以为null，因此可空引用类型并不是一个新的类型，只是用于辅助编译器检查潜在的null错误。\n不可为 null 的引用类型在取消引用时应该始终是安全的，因为它们的 null-state 是 not-null。 若强制执行该规则，如果不可为 null 的引用类型没有初始化（以任何形式）为非 null 值，编译器将发出警告。\n对比而言，可为null的引用类型必须在取消对变量的引用之前确定该变量的状态为 not-null（使用!= null或者is not null）。 如果可为 null 的引用的状态确定为 maybe-null，将其分配给不可为 Null 的引用变量会生成编译器警告。\n对于将非not-null状态的值赋值给not-null状态的引用变量时：\n如果要赋值为null，需要使用null!来向编译器强调。 如果要赋值为可为null的引用类型，需要在变量名后面加上!来强调。 同时需要自行维护因为暂时地违反规则而导致的空引用问题。\n成员访问 Null运算符?.和?[] 仅当操作数的计算结果为非 NULL 时，NULL 条件运算符才对其操作数应用成员访问 (?.) 或元素访问 (?[]) 操作；否则，它会返回 null。 换句话说：\n如果 a 的计算结果为 null，则 a?.x 或 a?[x] 的结果为 null。 如果 a 的计算结果为非 null，则 a?.x 或 a?[x] 的结果将分别与 a.x 或 a[x] 的结果相同。 ^和..选择符 ^和..选择符只能用于单维数组。\n^选择符指示序列末尾的元素位置，比如^1指向最后一个元素。\n..选择符指定索引范围的开始和结束作为其操作数， 左侧操作数是范围的包含性开头。 右侧操作数是范围的包含性末尾。通过省略 .. 运算符的任何操作数，可以获得一个开放区间：\na.. 与 a..^0 等效 ..b 与 0..b 等效 .. 与 0..^0 等效 C# 9.0 记录record record是引用修饰符，用于提供封装数据的内置功能。record class 语法等价于record，record struct 则用于定义一种具有类似功能的值类型。比如：\n// 位置参数语法形式 public record Person(string FirstName, string LastName); // 等价于 public record Person { public string FirstName { get; init; } public string LastName { get; init; } }; public record struct Point { public double X { get; init; } public double Y { get; init; } public double Z { get; init; } } 同时不强制属性为只读，任何不符合需求的自动生成样式都可以通过声明相同的字段、属性来更改，比如：\npublic record Person(string FirstName, string LastName, string Id) { internal string Id { get; init; } = Id; } record关键字主要提供了以下内容：\n值相等性比较，相比引用值比较，record默认使用值相等比较，同时额外比较类型，如果类型不相同就不等。\n内置的输出格式，将以\u0026lt;type\u0026gt; {xx : xx, xx : xx}的格式默认重载ToString函数\n非破坏性变化声明（with），例如：\npublic record Person(string FirstName, string LastName) { public string[] PhoneNumbers { get; init; } } Person person1 = new(\u0026#34;Nancy\u0026#34;, \u0026#34;Davolio\u0026#34;) { PhoneNumbers = new string[1] }; Console.WriteLine(person1); Person person2 = person1 with { FirstName = \u0026#34;John\u0026#34; }; 引用型的浅不可变性，即在多线程环境下不会发生值的改变，但是引用属性的指向可以发生改变。\nrecord class之间可以继承，比如：\npublic abstract record Person(string FirstName, string LastName); public record Teacher(string FirstName, string LastName, int Grade) : Person(FirstName, LastName); 但是在使用with表达式时，你只能编辑声明的变量的类型的字段，而不是with的对象的实际类型\ninit关键字 init 关键字在属性或索引器中定义访问器方法。 init-only 资源库仅在对象构造期间为属性或索引器元素赋值。 init 强制实施不可变性，因此，一旦初始化对象，将无法更改，必须通过调用构造函数来初始化。\ninit访问器不强制提供值，如果没有显示给出值，将初始化为该类型的默认值。与private set和readonly的区别是，init不要求一定在构造函数中，也可以使用对象初始值设定项（new \u0026lt;type\u0026gt;() {xx = xx, xx = xx}）\nC# 11.0 原始字符串 原始字符串字面量以至少三个双引号 (\u0026quot;\u0026quot;\u0026quot;) 字符开头。 它以相同数量的双引号字符结尾，无需转义序列。 比如：\nstring longMessage = \u0026#34;\u0026#34;\u0026#34; This is a long message. It has several lines. Some are indented more than others. Some should start at the first column. Some have \u0026#34;quoted text\u0026#34; in them. \u0026#34;\u0026#34;\u0026#34;; var location = $$\u0026#34;\u0026#34;\u0026#34; You are at {{{Longitude}}, {{Latitude}}} \u0026#34;\u0026#34;\u0026#34;; 如果要使用内插，使用多少个$就需要多少个大括号{}表示内插。\n泛型Attirbute Attribute可以使用泛型定义，但是在使用的时候比如给出所有的类型参数，而不能使用另一个泛型参数，比如：\npublic class GenericAttribute\u0026lt;T\u0026gt; : Attribute { } public class GenericType\u0026lt;T\u0026gt; { [GenericAttribute\u0026lt;T\u0026gt;()] // 不合法，T不是具体类型 public string Method() =\u0026gt; default; } required修饰符 required修饰符强制字段或属性使用对象初始值设定项进行初始化，该字段的可见性应该至少与其包含类型一样可见，且不可被隐藏。对于record中，必须显示指定required属性/字段的定义，而不是使用位置参数声明。\nC# 12.0 主构造函数 在定义类的时候，可以直接给出一个构造函数的参数列表，这些参数可以当作局部变量用于整个类，比如：\npublic class Employee(int id, string name) { public int Id { get; } = id; public string Name { get; } = name; public void Display() { Console.WriteLine($\u0026#34;Employee ID: {id}, Name: {name}\u0026#34;); } } 集合表达式 集合表达式中的 分布元素，..e 添加该表达式中的所有元素。 参数必须是集合类型。比如：\nint[] row0 = [1, 2, 3]; int[] row1 = [4, 5, 6]; int[] row2 = [7, 8, 9]; int[] single = [.. row0, .. row1, .. row2]; ..元素计算枚举表达式的每个元素。 每个元素都包含在输出集合中。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/c%23%E6%90%AC%E8%BF%90/c%23-update2/","summary":"C#8.0 - C#12.0 特性/语法糖搬运","title":"C# 更新记录 II"},{"content":"C# 更新记录 在此记录C#版本更新时带来的新特性，并给出C#版本和使用场景的对应关系。\n版本映射 C#版本 更新年份 .NET 框架 使用场景 4.0 2010 .NET Framework 4 《C#高级编程（第7版）》 5.0 2012 .NET Framework 4.5 6.0 2015 .NET Framework 4.6 7.0 2017 .NET Framework 4.6.2 7.1 2017 .NET Framework 4.7 7.2 2017 .NET Framework 4.7.1 7.3 2018 .NET Framework 4.7.2 8.0 2019 .NET Standard2.1 Unity 2023版本使用 9.0 2020 .NET 5 10.0 2021 .NET 6 11.0 2022 .NET 7 12.0 2023 .NET 8 Godot 4.4+版本使用/现长期支持版本 13.0 2024 .NET 9 C# 5.0 C#5.0引入了async/await语法糖，这一点已经被广泛使用，无需赘述。除此之外，加入了对调试很有帮助的调用方信息特性，也就是[CallerMemberNames]、[CallerLineNumber]、[CallerFilePath]和[CallerArgumentExpression]属性。\n通过向函数的参数中标记特性，可以自动获取对应的string，例如：\npublic void TraceMessage(string message, [CallerMemberName] string memberName = \u0026#34;\u0026#34;, [CallerFilePath] string sourceFilePath = \u0026#34;\u0026#34;, [CallerLineNumber] int sourceLineNumber = 0); 后面三个参数分别获取了调用成员的名称，调用文件的路径（编译时），调用文件的行号。\n而[CallerArgumentExpression]会将表达式转化为string并输出，例如：\npublic void Validate(bool condition, [CallerArgumentExpression(\u0026#34;condition\u0026#34;)] string? message=null); Validate(nameof(func), func is not null); 此时message的值会自动设置为传入的表达式转化为string的值即\u0026quot;func is not null\u0026quot;。\nC# 6.0 C#6.0更新了很多更有效率的小功能，包括经常被使用的表达式体函数（就是=\u0026gt;定义函数内容/返回值）、还有?.、?[]运算符等等，这些由于已经被经常使用而不再赘述。\n第一个介绍的特性是nameof表达式，可用于生成变量、类型或成员的名称作为字符串常量，在编译时求值。相比于硬编码，nameof表达式提供了类型安全检查，确保对象存在才能通过编译，并且能够被重构工具识别，无需手动修改。\n第二个介绍的特性是异常筛选，通过when关键字给出的表达式用于额外判断catch语句是否执行，可用于对异常处理的情况进行细分，特别是在网络传输中。例如：\ncatch (HttpRequestException e) when (e.Message.Contains(\u0026#34;301\u0026#34;)) { } catch (HttpRequestException e) when (e.Message.Contains(\u0026#34;404\u0026#34;)) { } C# 7.0 C#7.0更新了很多有用的新特性，下面将展开叙述。\n简单解释的特性有out参数和throw表达式，前者用于实现多值return，后者用于在条件运算符（? :）、null合并运算符（??）和=\u0026gt;表达式中直接抛出异常。\n元组和析构 元组（System.ValueTuple）的行为和Python中很类似，可以原生进行打包和解包（析构），但是C#中的元组是静态类型，具有类型安全检查。\n元组可以显式给每个成员命名，使用字段名使用而不是索引访问，如果未指定，则默认按照Item1、Item2的顺序给出字段名。\n(double, int) t1 = (4.5, 3); Console.WriteLine($\u0026#34;Tuple with elements {t1.Item1} and {t1.Item2}.\u0026#34;); (double Sum, int Count) t2 = (4.5, 3); Console.WriteLine($\u0026#34;Sum of {t2.Count} elements is {t2.Sum}.\u0026#34;); ref变量 ref变量类似于C++中的指针和引用的结合体，但是提供了类型安全检查，且不具有指针所有的危险性，以及引用的不可变性。\n= ref是引用赋值运算符，用于更改引用引用的对象，ref readonly限制了不能使用普通的赋值运算符，但依旧可以使用赋值运算符。\nint variable = 0, anotherVarible = 1; ref int aliasOfvariable = ref variable; aliasOfvariable = ref anotherVarible; 同时，函数可以返回ref变量，根据接收者是不是ref变量决定使用引用赋值还是普通赋值，但是和C++一致的是，返回ref的源对象生命周期一定要超过函数内，同时每一处return语句都需要加上ref修饰。\npublic static ref int Find(int[,] matrix, Func\u0026lt;int, bool\u0026gt; predicate) { for (int i = 0; i \u0026lt; matrix.GetLength(0); i++) for (int j = 0; j \u0026lt; matrix.GetLength(1); j++) if (predicate(matrix[i, j])) return ref matrix[i, j]; throw new InvalidOperationException(\u0026#34;Not found\u0026#34;); } 模式匹配 模式匹配用于检测表达式是否具有某种特征，主要由is和switch表达式（由C#8.0添加）来判断，前者用于匹配单个模式，后者用于批量处理多种模式。在不同的模式之间，可以使用and、not、or来组合不同的模式。\n声明和类型模式匹配 用于检测是否与指定类型匹配（继承或实现），对于可空变量，is \u0026lt;realType\u0026gt;匹配同时会先额外匹配is not null。可以在匹配之后声明变量，之后可以将新变量当声明类使用。\nsequence is IList\u0026lt;T\u0026gt; list sequence is not null 常量模式匹配 用于匹配和常量值相等的模式，例如：\ncommand is \u0026#34;SystemTest\u0026#34; var模式匹配 用于匹配任何表达式（包括 null），并将其结果分配给新的局部变量，例如：\nSimulateDataFetch(id) is var results 在is表达式中，var可以省略，但是在嵌套模式匹配中（列表、位置、属性）中，则不能省略某个子匹配的var。\n弃元模式匹配 用于匹配任何表达式（包括 null），并丢弃值，例如：\n// 该表达式会永远返回true a is _ 关系模式匹配 用于匹配满足大小关系的模式，例如：\ntempInFahrenheit is \u0026lt; 32 列表模式匹配 用于根据列表内容来匹配模式，使用弃元_来匹配任何元素，使用切片模式..来匹配零个或任意个元素。该匹配等效于对列表中的每一个元素再做一次模式匹配，使用样例如下：\ntransaction is [_, \u0026#34;WITHDRAWAL\u0026#34;, .., var amount] 弃元 弃元（_）是一种在应用程序代码中人为取消使用的占位符变量，用于忽略表达式的值。弃元不是变量，而是一种丢弃值的说明，除非上下文中已经定义了标识符为_的对象。\n第一种用途是元组的解包，对于不关注的值可以使用弃元来丢弃，例如：\n(_, _, area) = city.GetCityInformation(cityName); 第二种用途是switch匹配，在上一章中已经说明。\n第三种用途是给out变量使用，用于忽视输出，例如：\nDateTime.TryParse(dateString, out _) 最后一种是独立弃元来指示要忽略的任何变量，比如使用弃元来让无法单独存在的表达式变成语句而得以执行，比如??表达式，或者对于异步任务的执行表示不等待执行、不捕获异常也不关心返回值。例如：\n_ = arg ?? throw new ArgumentNullException(); _ = Task.Run(() =\u0026gt; { ... }); C# 8.0 C# 8.0更新了很多的特性，这里仅介绍一部分特性，剩下的特性将在下一篇文章中介绍。\nreadonly readonly可以用于修饰struct，表示所有成员都是只读，不能在构造之后修改值，这里遵循的是最严格的值不变性。\nreadonly也可以用于struct或者class的某个成员，比如方法、属性get和字段。对于引用类型，加入readonly值之后只能保证引用的对象不会改变，但仍然可以修改对象包含的内容。\nusing声明 使用using语句可以保证只读变量被正确释放，在离开using语句块的时候，会自动释放获取的 IDisposable 实例。如果因为异常提前离开了语句块，也会依旧释放。using语句也可以不含代码块，将会在它的作用域末尾自动释放，比如函数结束。\n针对IAsyncDisposable，可以使用await using声明。使用样例如下：\nusing (StreamReader reader = File.OpenText(\u0026#34;numbers.txt\u0026#34;)) { } await using (var resource = new AsyncDisposableExample()) { } using StreamReader reader = File.OpenText(filePath); 模式匹配 C#8.0中新增了switch表达式，该表达式会一次匹配多个模式，并针对每一个模式返回一个表达式值。\n除此之外，模式匹配部分还新增了两种模式：属性、位置。\n位置模式匹配 用于对一个元组进行模式匹配，如果一个对象实现了Deconstruct函数那么可以将该对象自动解包并以元组的形式进行模式匹配。元组模式匹配类似于列表模式匹配，依旧相当于对于每一个元素做模式匹配。使用样例如下：\npoint switch { (0, 0) =\u0026gt; \u0026#34;Origin\u0026#34;, (1, 0) =\u0026gt; \u0026#34;positive X basis end\u0026#34;, (0, 1) =\u0026gt; \u0026#34;positive Y basis end\u0026#34;, _ =\u0026gt; \u0026#34;Just a point\u0026#34;, }; 属性模式匹配 用于对一个对象是否具有指定字段/属性且满足子模式匹配进行模式匹配，需要指出字段/属性的名称，以及该字段/属性需要匹配的模式。本质类似于列表和位置模式匹配，都是进行嵌套的模式匹配。使用样例如下：\ninput switch { string { Length: \u0026gt;= 5 } s =\u0026gt; s.Substring(0, 5), string s =\u0026gt; s, ICollection\u0026lt;char\u0026gt; { Count: \u0026gt;= 5 } symbols =\u0026gt; ... ICollection\u0026lt;char\u0026gt; symbols =\u0026gt; new string(symbols.ToArray()), null =\u0026gt; ..., _ =\u0026gt; ..., }; 样例中的第一个模式匹配string类型，且此类型有一个字段/属性Length，满足\u0026gt;=5这一模式匹配。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/c%23%E6%90%AC%E8%BF%90/c%23-update1/","summary":"C#5.0 - C#8.0 特性/语法糖搬运","title":"C# 更新记录 I"},{"content":"ASP.NET后端笔记 架构 创建项目后，会默认实现一个天气预报的API，通过Program.cs文件来配置后端内容，Controllers负责定义具体的API内容。\nASP.NET WebCore API项目的架构很简单，就是由很多个Controllers构成，其余的部分都会由框架自动生成，比如说URL解析，接收并监听端口等服务端必需的功能。但是如果想要实现身份验证、连接数据库，就需要额外的配置，推荐使用Docker来部署后端来简化内部连接。\n无论采用哪一个数据库，后端在设计的时候都需要一个和具体的数据库无关的数据结构，也就是ORM（数据库关系映射）。同时对数据库的表的设计不应该直接使用SQL语句进行编辑，而是根据定义的数据结构来自动创建和修改，也就是迁移。\n注意连接和迁移是两码事，连接指的是后端运行时，而迁移无关后端，可以在任何项目中发生。\n数据库连接 这里我们采用Microsoft.AspNetCore.Identity.EntityFrameworkCore包来执行，并且在Docker-Compose的文件中设置连接数据库的key，比如：\napi: environment: - ConnectionStrings__DefaultConnection=Server=db;Port=${DB_PORT};Database=${POSTGRES_DB};User Id=${POSTGRES_USER};Password=${POSTGRES_PASSWORD} 在确认了连接之后，还需要在Program.cs中配置将数据库和DbContext关联起来，这里就和特定的数据库类型有关了，因此需要下载对应的包，比如Microsoft.EntityFrameworkCore.Sqlite包，然后加入如下的代码：\nbuilder.Services.AddDbContext\u0026lt;AppContext\u0026gt;(options =\u0026gt; options.UseSqlite(configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;))); 如此在启动时便自动连接上了数据库，注意环境变量的设置不仅仅可以通过Docker-Compose来设置，只是如果使用Docker启动这样做最方便，同时为了保证隐私，需要使用.env文件将重要的字段分开存储，并从版本管理中排除。\n数据库迁移 首先迁移进行的前提就是有一个DbContext，比如：\npublic class AppContext : DbContext { public AppContext(DbContextOptions\u0026lt;AppContext\u0026gt; options) : base(options){ } protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); // ...数据关系定义（外键，主键） } public DbSet\u0026lt;Song\u0026gt; SongData { get; set; } public DbSet\u0026lt;Game\u0026gt; GameData { get; set; } } 通过程序包管理器控制台或者dotnet命令行（需要在项目根目录下执行）可以执行迁移文件的生成和执行。指令如下：\n# 生成迁移文件 Add-Migration \u0026lt;MigrationName\u0026gt; # 或者是 dotnet ef migrations add \u0026lt;MigrationName\u0026gt; # 移除上一个迁移文件 Remove-Migration # 或者是 dotnet ef migrations remove # 执行迁移 Update-Database # 或者是 dotnet ef database update 迁移文件的结构由Up和Down函数组成，分别用于正向将数据库迁移，反向将数据库还原，在生成之后可以手动修改细节来微调结构。\nController 处理完数据库之后，后端的任务就是根据请求URL来执行业务逻辑并返回，这里通过Controller来自动实现URL的解析，只需要将关注放在具体的业务函数上即可。一个典型Controller的结构如下：\n[ApiController] [Route(\u0026#34;api/[controller]\u0026#34;)] public class GameController : ControllerBase { // GET: api/game [HttpGet] public async Task\u0026lt;ActionResult\u0026lt;IEnumerable\u0026lt;Game\u0026gt;\u0026gt;\u0026gt; GetGames() { //... return Ok(games); } [HttpGet(\u0026#34;{gameId}/versions\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;IEnumerable\u0026lt;string\u0026gt;\u0026gt;\u0026gt; GetGameVersions([FromRoute] int gameId) { //... if (!gameExists) return NotFound($\u0026#34;Game with ID {gameId} not found.\u0026#34;); //... return Ok(game); } } [ApiController]属性指出该类是一个构建API所需的控制器，[Route]属性指出解析URL时，路径的前缀是什么，[HttpGet]属性指出该函数对应的API URL后缀是什么，[FromRoute]表示从URL中获取的一个变量，变量名需要和[HttpGet]中完全一致。\n在此例子中，GetGames的URL是{IP:Port}/api/game，而GetGameVersions的是 {IP:Port}/api/game/{gameId}/versions，其中 gameId 表示任何一个int，将作为变量输入函数。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/c%23%E6%90%AC%E8%BF%90/asp-net-backend-note1/","summary":"C#后端方案","title":"ASP.NET后端笔记 I"},{"content":"CursorEngine 笔记 MVVM ToolKit 拓展 手动去实现MVVM十分复杂，需要写很多额外的属性和事件，而CommunityMVVM Toolkit利用源生成器可以简化对应的实现，通过属性来标记需要监控的属性和需要绑定的指令。若要使用Toolkit，目标类一定要设置为partial并继承ObservableObject。\n[ObervableProperty]用于为一个字段生成对应的属性，通过属性修改字段值是会通知变更事件的订阅者，这一属性可以广泛用于xaml文件中的{Binding}。\n[RelayCommand]用于生成一个通用的用于绑定Command字段的属性，可以通过构造函数中声明CanExecute = nameof(XXX)来控制Command的可执行与否。\n[NotifyCanExecuteChangedFor]用于为[RelayCommand]的CanExecute条件是否满足的变化提供通知，如果CanExecute指定的属性没有附加此Attribute，那么Command的能否执行只取决于属性的初始值，而不是实时值。\nWindows API 针对特定系统会有特定的底层函数调用，但是需要额外的导入工作，对于C#而言，需要[DllImport]属性来导入系统dll中的系统函数，例如：\n[DllImport(\u0026#34;user32.dll\u0026#34;, CharSet = CharSet.Auto)] public static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type); 手动声明容易出错，微软为我们提供了一个方便的NuGet包：Microsoft.Windows.CsWin32\n导入后，会在项目根目录下面生成一个NativeMethod.txt，向其中输入需要调用的底层API，就会自动生成带DllImport的声明。在调用时，通过预先生成好的静态类PInvoke来调用声明的函数。\n如果使用CsWin32不能满足需求或者说使用时会出错，那么这个时候必须手动声明DllImport。\nDataContext DataContext是针对Control和Window而言的绑定上下文，可以通过xaml文件指定也可以通过代码指定，比如:\n\u0026lt;v:LocalSchemeControl DataContext=\u0026#34;{Binding LocalSchemeVM}\u0026#34;/\u0026gt; var renamePanel = _serviceProvider.GetRequiredService\u0026lt;RenamePanel\u0026gt;(); renamePanel.DataContext = renameViewModel; 同样，Control可以针对DataContext修改的事件进行反向回调注册，比如：\nthis.DataContextChanged += (s, e) =\u0026gt; { if (e.NewValue is RenameViewModel vm) { vm.CloseAction = (result) =\u0026gt; { try { this.DialogResult = result; } catch (InvalidOperationException) { this.Close(); } }; } }; 在数据绑定的时候，不一定非要从当前的DataContext中寻找，也可以顺着UI树向上寻找DataContext进行绑定，比如：\n\u0026lt;Button Command=\u0026#34;{Binding DataContext.NavigateCommand, RelativeSource={RelativeSource AncestorType=Window}}\u0026#34;/\u0026gt; 上述绑定方式表示沿着UI树向上寻找第一个Window对象，从该对象的DataContext中绑定NavigateCommand这一指令。上述绑定方式常用于控制页面/主控件切换。\n如果绑定的Command是一个带参函数，可以将Control本身的DataContext作为参数输入，比如：\n\u0026lt;Button Command=\u0026#34;{Binding DataContext.ViewCommand, RelativeSource={RelativeSource AncestorType=ListBox}}\u0026#34; CommandParameter=\u0026#34;{Binding}\u0026#34;/\u0026gt; 上述绑定方式表示绑定了一个单参数的ViewCommand，通过CommandParameter设置将控件自身DataContext输入。\nWPF窗口和WPF控件 在WPF中，控件(Control)是组成UI界面的基本元素，而窗口(Window)是一类特殊的控件，默认创建的MainWindow就是应用开启时自动打开的Window。\n具体来说，窗口是顶级容器，用于容纳其他的Control，在Windows系统上窗口的反映就是任务栏应用图标上的标签页数量，创建多少个显示的窗口，就有多少个预览页。尽管窗口不能脱离操作系统存在，但是不代表窗口一定要和操作系统的样式完全一致。常见的Window样式设置比如：\n\u0026lt;Window Style=\u0026#34;{StaticResource MaterialDesignWindow}\u0026#34; Background=\u0026#34;{DynamicResource MaterialDesignPaper}\u0026#34; WindowStyle=\u0026#34;SingleBorderWindow\u0026#34; ResizeMode=\u0026#34;NoResize\u0026#34; WindowStartupLocation=\u0026#34;CenterOwner\u0026#34;\u0026gt; 有的时候，单一MainWindow不能满足软件的需求，或者将所有功能继承在一个窗口内显得很臃肿，自然需要唤起子界面/同级页面来处理。比如：\nvar renamePanel = _serviceProvider.GetRequiredService\u0026lt;RenamePanel\u0026gt;(); renamePanel.Owner = Application.Current.MainWindow; var dialogResult = renamePanel.ShowDialog(); 这里的RenamePanel是通过DI注入的Transient服务，以上代码请求创建一个RenamePanel，并将其父窗口设置为目前的主窗口，然后将其作为Dialog显示。Dialog表示同步且阻塞的显示方式，返回一个bool?值表示操作结果，通常true表示操作完成，false表示操作放弃，null表示按下窗口的关闭按钮。\nMaterialDesign MaterialDesign是一个提供控件扩展和样式扩展的Nuget包，引入了Google Material Design 的设计原则。\n对于控件拓展，这里主要讲述Transition，用于控制多个子Control之间的切换动画。样例如下：\n\u0026lt;md:Transitioner SelectedIndex=\u0026#34;{Binding CurrentPageIndex}\u0026#34;\u0026gt; \u0026lt;md:TransitioningContent\u0026gt; \u0026lt;md:TransitioningContent.OpeningEffect\u0026gt; \u0026lt;md:TransitionEffect Kind=\u0026#34;SlideInFromLeft\u0026#34; Duration=\u0026#34;0:0:0.3\u0026#34;/\u0026gt; \u0026lt;/md:TransitioningContent.OpeningEffect\u0026gt; \u0026lt;/md:TransitioningContent\u0026gt; \u0026lt;md:TransitioningContent\u0026gt; \u0026lt;md:TransitioningContent.OpeningEffect\u0026gt; \u0026lt;md:TransitionEffect Kind=\u0026#34;SlideInFromLeft\u0026#34; Duration=\u0026#34;0:0:0.3\u0026#34;/\u0026gt; \u0026lt;/md:TransitioningContent.OpeningEffect\u0026gt; \u0026lt;/md:TransitioningContent\u0026gt; \u0026lt;/md:Transitioner\u0026gt; SelectedIndex是Transitioner用于控制Context显示的变量，当其绑定值发生变化的时候，会自动地切换控件的Content。\nTransitioningContent就是类似于幻灯片存在的容器，在其中放置想要显示的内容，并指定OpeningEffect，就会在变化的时候采用动画而不是僵硬的阻塞加载-瞬间变化处理，增加了用户体验。\nTaskBarIcon 很多时候，我们希望应用不仅仅是以窗口的形式运行，还希望它能够挂载在后台，只有在需要更改配置的时候才唤起，这个时候就需要用到系统任务栏托管，通过导入H.NotifyIcon.Wpf Nuget包来使用。\n\u0026lt;tb:TaskbarIcon x:Name=\u0026#34;TaskbarIcon\u0026#34; IconSource=\u0026#34;/cursor.ico\u0026#34; ToolTip=\u0026#34;Cursor Engine\u0026#34; LeftClickCommand=\u0026#34;{Binding ShowCommand}\u0026#34; Grid.ColumnSpan=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;tb:TaskbarIcon.ContextMenu\u0026gt; \u0026lt;ContextMenu\u0026gt; \u0026lt;MenuItem Height=\u0026#34;20\u0026#34; Header=\u0026#34;显示\u0026#34; Command=\u0026#34;{Binding ShowCommand}\u0026#34;/\u0026gt; \u0026lt;Separator/\u0026gt; \u0026lt;MenuItem Height=\u0026#34;20\u0026#34; Header=\u0026#34;退出\u0026#34; Command=\u0026#34;{Binding ExitCommand}\u0026#34;/\u0026gt; \u0026lt;/ContextMenu\u0026gt; \u0026lt;/tb:TaskbarIcon.ContextMenu\u0026gt; \u0026lt;/tb:TaskbarIcon\u0026gt; 在MainWindow中声明如上的代码，可以为软件添加系统托管，其中\u0026lt;ContextMenu\u0026gt;标签定义了右键上下文菜单，然后通过如下的代码来额外添加窗口的生命周期控制，便可以像音乐软件那样挂载在后台运行而不显示窗口。\n//关闭窗口时到后台运行 protected override void OnClosing(CancelEventArgs e) { e.Cancel = true; Hide(); base.OnClosing(e); } //注销TaskBar public void OnApplicationExit() =\u0026gt; Dispatcher.Invoke(() =\u0026gt; TaskbarIcon.Dispose()); //显示窗口 [RelayCommand] public void ShowWindow() { var mainWindow = _serviceProvider.GetRequiredService\u0026lt;MainWindow\u0026gt;(); mainWindow.Show(); mainWindow.Activate(); } //真正的退出程序 [RelayCommand] public void ExitApplication() =\u0026gt; Application.Current.Shutdown(); ","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/c%23%E6%90%AC%E8%BF%90/cursorengine-note/","summary":"CursorEngine 项目开发复盘","title":"CursorEngine 笔记"},{"content":"Docker使用及迁移 最近在折腾Docker，容器的理念非常先进，使用起来一个直观的感受就是，再也不用配麻烦的环境配半天了。\n容器化是什么 为了解决“代码能在我的电脑上跑”的问题，可以将一个项目的一切包括运行环境依赖项、构建依赖项等打包成一个能在任何环境下运行的“集装箱”，当需要在别的设备上运行时，会自动根据配置获取依赖，无需手动操作。这些“集装箱”之间相互独立、互不影响，使得每一个项目都获取了很大的隔离性。\n这样的过程，就是容器化，容器之间可以共享操作系统，因此相比于虚拟机而言更加轻量级，是迁移项目，部署多服务项目的优良选择。\n三种实体 可能看到上面的内容，依然很迷惑。其实，只需要了解Docker最重要的三种实体就可以明白容器化到底在做什么。这三种实体是：Image，Container和Volume。从实际的效果上来说，可以认为Image是系统映像，Container是运行在系统上的实际操作系统，Volume就是文件系统中的根目录及下面的文件。\nImage是静态的文件集合，它包含了运行时需要的所有内容，通过DockerFile构建得到的对象就是Image，相当于Docker系统内的“exe文件”。Image在构建之后就不会被修改，以C#控制台程序为例，我们在源码中加入一个DockerFile并构建，就是先进行编译，然后将得到的文件封装成整体为Image，之后就可以运行这个Image，通过指令调用来正常的使用这个控制台程序。除了自己编译之外，Docker社区中也存在着大量的镜像Image比如PostgreSQL镜像，可以直接下载并运行，无需额外的操作。\nContainer是基于Image的运行时整体，可以认为有自己的操作系统，执行着文件系统里面的内容，同时有着自己的内部网络和端口，相当于“运行时的进程”。比如说PostgreSQL镜像运行起来的Container就等同于一个SQLServer，只不过Container是不存在离线状态的，也就是说无论启动多少次，Container的运作方式都是一样的。\nVolume是数据卷，用于持久化容器的运行时数据，数据卷对容器是独立的，一个数据卷可以挂载到任何一个容器中，就像移动U盘一样。\n那么一个项目的迁移部署流程就是：下载源码和DockerFile，Build生成Image，或者直接下载Image，然后基于Image构建Container，之后的效果就如同本地测试一般。\nDocker-Compose 由于每一个Container都可以视为一个独立的主机，将物理端口映射为自己的虚拟端口。\n为了将多个Container聚合在一起，并能够相互之间方便的交流，使用Docker-Compose工具可以利用持久化文件来管理多个Container，而不用每次一个一个使用docker指令运维，同时将一个项目内的所有Container放置在一个虚拟网络中，可以以http://{服务名}的方式互相访问。除此之外，docker-compose.yml文件还可以定义容器间的依赖关系以指定启动顺序、指定Image构建方式、提供环境变量和数据卷路径等配置，基本上满足了自定义部署的需求。\n下面给出一个PostgreSQL镜像部署的例子：\nservices: db: image: postgres:latest restart: always environment: - POSTGRES_USER=${POSTGRES_USER} - POSTGRES_PASSWORD=${POSTGRES_PASSWORD} - POSTGRES_DB=${POSTGRES_DB} volumes: - postgres_data:/var/lib/postgresql/data networks: xxx_network: driver: bridge 这里的${POSTGRES_USER}之类的参数由同目录下的.env文件定义，在DockerCompose文件中最好不要硬编码敏感字段。\n容器调试 容器可以理解为一个独立主机，在需要调试的时候，就需要进入到容器网络中，或者进入到某个指定的容器中，这个时候就要使用docker exec指令。\ndocker exec -it xxx sh docker exec -it xxx dotnet xxx.dll 上述指令可以进入指定的容器，并在容器内附加一个sh进程或者启动一个写好的C#控制台程序，此时可以理解为通过SSH连接方式进入了远程服务器内部并启动了一个沟通终端，可能有正在运行的Web服务器，也有可能有很多等待手动执行的测试脚本/程序。\n端口映射 如果不进行端口映射，容器本身就是一个孤立的城堡，只能和网络内的其他容器沟通，而无法连接Internet。\n首先要引入防火墙的概念，物理服务器并不会开放所有的端口，它只会对设定规则内的端口开放出入流量。\n其次，容器如果想要监听某个物理端口，就需要显式地指出来，比如说8080：80，如果物理服务器在8080端口有流量输入，那么这个流量会自动转发到容器的80端口。同样，如果容器要回复，也是将流量发送至自己的80端口，然后转发到物理服务器的8080端口，最后发送到客户端。在客户端的角度，它认为自己一直是在和物理服务器进行交流，而无法得知具体执行的的转发和IP修改。\n总而言之，端口映射解决的是容器和公网的连接，虚拟网络解决的是容器之间的连接。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/linux%E6%90%AC%E8%BF%90/docker/","summary":"第一次使用Docker并在Ubuntu上部署","title":"Docker使用及迁移"},{"content":"WPF笔记 MVVM模型 在实际的开发过程中，使用MVVM模型能够降低各组件之间的耦合度，增加单元可测试性。具体来说就是Model-View-ViewModel，其中View就是WPF默认给出的UI这个模块，Model是在后台负责执行具体的业务逻辑，和数据库进行沟通的模块，而ViewModel就是将二者串起来的桥梁，负责将业务逻辑和UI绑定。\nView可以仅靠xaml和少量的C#构建，把DataContext设置为ViewModel即可，View基本上是不存在状态的，只是对ViewModel的绑定数据的显示。\nViewModel提供一些基本的字段供View绑定，同时封装了Model的部分底层逻辑接口，供View使用，ViewModel是存在状态的，因此提供了变量和属性来存储状态值。\nModel是负责与数据库或者系统进行交流的底层模块，是程序业务实际执行的模块，能根据ViewModel给出的指令组合来依次完成任务。\nICommand 为了让UI能够执行逻辑，WPF控件利用ICommand接口来绑定操作。ICommand接口需要实现以下三个方法：\nbool CanExecute(object parameter); void Execute(object parameter); event EventHandler CanExecuteChanged; ICommand指出了绑定之后的控件能够做什么，什么时候能触发，什么时候可触发性改变。而ViewModel只需要提供一个公开的ICommand get接口，就可以在控件的Command属性中绑定。比如说Button和点击和Textbox的按键输入：\n\u0026lt;TextBox\u0026gt; \u0026lt;TextBox.InputBindings\u0026gt; \u0026lt;KeyBinding Key=\u0026#34;Enter\u0026#34; Command=\u0026#34;{Binding XXXXCommand}\u0026#34; /\u0026gt; \u0026lt;/TextBox.InputBindings\u0026gt; \u0026lt;/TextBox\u0026gt; \u0026lt;Button Command=\u0026#34;{Binding XXXXCommand}\u0026#34;/\u0026gt; Style Style标签用于定义可重复使用的样式块。\n如果是需要重用的Style，使用x:Key属性命名定义的Style，在之后就可以以Style=\u0026quot;{StaticResource XXXX}\u0026ldquo;方式应用这个Style。\n如果是仅仅用到一次，可以在\u0026lt;控件.Style\u0026gt;标签中定义Style标签，比如：\n\u0026lt;Border\u0026gt; \u0026lt;Border.Style\u0026gt; \u0026lt;Style TargetType=\u0026#34;Border\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Visibility\u0026#34; Value=\u0026#34;Visible\u0026#34; /\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/Border.Style\u0026gt; \u0026lt;/Border\u0026gt; Style标签中最常见的就是Setter标签，用于将某个属性设置为指定值。如果想要让Style支持在不同的条件下给出不同的值，可以用\u0026lt;Style.Triggers\u0026gt;来定义行为：\n\u0026lt;Style.Triggers\u0026gt; \u0026lt;Trigger Property=\u0026#34;IsMouseOver\u0026#34; Value=\u0026#34;True\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Background\u0026#34; Value=\u0026#34;#33FFFFFF\u0026#34;/\u0026gt; \u0026lt;/Trigger\u0026gt; \u0026lt;DataTrigger Binding=\u0026#34;{Binding ErrorText}\u0026#34; Value=\u0026#34;{x:Null}\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Visibility\u0026#34; Value=\u0026#34;Collapsed\u0026#34; /\u0026gt; \u0026lt;/DataTrigger\u0026gt; \u0026lt;/Style.Triggers\u0026gt; Style中有一个非常特殊的属性Template，它允许你在保留这个控件根类型的情况下重新控制它的子控件的绘制。比如下面的代码，这里面又有一个特殊的ContextPresenter，它是用于将Button的Content属性放到此处。这里的Content是一个广义的概念，可以是字符串，也可以是另一个组件。\n\u0026lt;Setter Property=\u0026#34;Template\u0026#34;\u0026gt; \u0026lt;Setter.Value\u0026gt; \u0026lt;ControlTemplate TargetType=\u0026#34;Button\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;{TemplateBinding Background}\u0026#34;\u0026gt; \u0026lt;ContentPresenter HorizontalAlignment=\u0026#34;Center\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34;/\u0026gt; \u0026lt;/Border\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/Setter.Value\u0026gt; \u0026lt;/Setter\u0026gt; ","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/c%23%E6%90%AC%E8%BF%90/wpf-note2/","summary":"MVVM模式","title":"WPF笔记 II"},{"content":"WPF笔记 架构 创建好WPF项目之后，会发现自带了App.xaml，App.xaml.cs，MainWindow.xaml和MainWindow.xaml.cs四个文件。\nApp.xaml：定义了全局的资源样式，以供控件使用。 App.xaml.cs：是应用的核心，规定了应用是怎么启动的，以及程序全局的行为，默认情况下会生成一个MainWindow并显示。 MainWindow.xaml：主要窗口的样式，规定了窗口需要包含什么样的组件，以及组件的属性值是如何。 MainWindow.xaml.cs：窗口背后运作的逻辑，可控xaml文件绑定函数。 可以看到，WPF项目中分为两种文件，一种是xaml，一种是cs。\nxaml文件给出的是对象的字段或者属性的值如何，也就是有什么内容，理论上任何类型都可以用xaml文件来配置。\ncs文件给出的是怎么利用字段和属性去运行，也就是内容怎么“动”起来。\nMicrosoft.Extensions.Hosting Microsoft.Extensions.Hosting是一个用于辅助构建.NET应用的Nuget包，通过一套标准的流程来启动项目，提供管理。\n在WPF中，比较常用的就是单例对象初始化和配置注入。\n单例对象初始化的作用是自动识别依赖关系按照顺序初始化指定的对象，比如将MainWindow注册。这样做的好处就是，当A对象的初始化需要B作参量的时候，如果AB配置在services中，会自动先初始化B，再初始化A。\nHost.CreateDefaultBuilder().ConfigureServices((hostContext, services) =\u0026gt; { services.AddSingleton\u0026lt;MainWindow\u0026gt;(); }).Build(); 配置注入是对应用的多个配置文件按照顺序加载并覆盖，最终得到一个IConfiguration对象供全局调用，包含所有的配置项，这个对象可以用于注册了服务的对象构造函数中。\nHost.CreateDefaultBuilder().ConfigureAppConfiguration((hostContext, config) =\u0026gt; { config.SetBasePath(Directory.GetCurrentDirectory()); config.AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: false, reloadOnChange: true); }).Build(); 除此之外还有日志输出和后台托管服务，这些在简单的WPF项目中使用较少。\n引入控件库 使用Visual Studio和C#最好的地方就是Nuget管理器，通过Nuget可以下载到各种控件库来使得UI更加美观，库中的内容分为样式和控件两个部分。\n控件部分是包额外提供实现的控件，和内置的Button等实现不同，也需要命名空间来导入，这些在xaml文件的根标签下，以类似下面给出的代码来定义。在导入之后，就可以用正常使用这些控件。\nxmlns:hc=\u0026#34;https://handyorg.github.io/handycontrol\u0026#34; 样式部分是包提供的可复用的全局属性值设置。通过ResourceDictionary导入之后，可以覆盖默认的UI绘制方式，类似于CSS文件。默认的UI绘制也是使用xaml文件来定义的，通过导入样式并覆盖，相当于给控件的默认绘制方式进行了美化。\n\u0026lt;ResourceDictionary\u0026gt; \u0026lt;ResourceDictionary.MergedDictionaries\u0026gt; \u0026lt;ResourceDictionary Source=\u0026#34;pack://application:,,,/HandyControl;component/Themes/SkinDark.xaml\u0026#34;/\u0026gt; \u0026lt;ResourceDictionary Source=\u0026#34;pack://application:,,,/HandyControl;component/Themes/Theme.xaml\u0026#34;/\u0026gt; \u0026lt;/ResourceDictionary.MergedDictionaries\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; Grid Grid作为WPF最基础的组件，用于提供一个可以精细化布局的基础控件，为其他的组件提供一个可定制布局的容器。其中，最为重要的两个属性就是RowDefinition和ColumnDefinition，二者用于精确的控制组件的位置关系以及每一行每一列的长宽。例如：\n\u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026#34;*\u0026#34;/\u0026gt; \u0026lt;ColumnDefinition Width=\u0026#34;Auto\u0026#34;/\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; 其中*表示占据剩余的位置，Auto则根据子组件的长宽来决定。而子组件想要放置在Grid当中，也需要定义属性Grid.Column和Grid.Row。\n扩展标记 扩展标记是xaml语言中用于实现复杂逻辑的属性值，通常以大括号{}的形式出现，表示该属性的值不是简单的字符串，而是需要通过复杂的逻辑来获取，常见的拓展标记有{Static Resource}和{Binding}。\n{StaticResource}表示静态地从资源资源中获取一个对象，比如说自定义的按钮图标，这样就不用在定义控件的时候给出绘制的长篇代码，并且也可以复用。\n{Binding}表示从数据上下文（也就是MainWindow的DataContext）中绑定一个公开的C#属性，偶尔也可能绑定别的UI的依赖项或者对象本身。绑定分为单向和双向，如果是单向的话，Binding后面指出的属性值（源属性）会反应到使用Binding的属性（目标属性）上，如果是双向的话，任意一方改变都会导致另一方改变。\n需要注意的是，如果想要支持绑定，一定要让DataContext对象实现INotifyPropertyChanged接口，这个接口要求支持绑定的属性在值变化时要发出通知，这样UI才知道值改变了。一个例子如下面代码所示：\npublic event PropertyChangedEventHandler? PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string? propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } public ObservableCollection\u0026lt;Song\u0026gt; SearchResults { get; } = new(); private string _errorText = string.Empty; public string ErrorText { get =\u0026gt; _errorText; set { if (_errorText != value) { _errorText = value; OnPropertyChanged(); } } } 前面的部分是INotifyPropertyChanged接口的一个简单实现，使用OnPropertyChanged包裹方便调用。\nObservableCollection是默认实现通知的列表，所以可以直接绑定，而ErrorText属性需要手动在值变动的时候通知，也就是调用OnPropertyChanged函数或者以PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(\u0026quot;ErrorText\u0026quot;))的形式调用，后者明显麻烦很多且存在不一致的隐患。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/c%23%E6%90%AC%E8%BF%90/wpf-note1/","summary":"WPF快速构建","title":"WPF笔记 I"},{"content":"任务概览 简单来说，就是先构建一个单周期RISC-V CPU，然后基于此加入中断和流水线功能，最终将二者合并在一起，所以作为根基的单周期CPU的设计一定要恰当，不然之后改进的时候就会很麻烦。每个人都有自己的四条专属的指令，建议在设计单周期CPU时就做完，以免之后每一个任务都额外去补充实现。\n以上是实现流程，红色为必做，蓝色为选作，完成图中所有内容后，理论上能拿到实践部分的满分。\n单周期RISC-V 先说流程，首先是填表（表的生成那一页的红色字体是自带的，不是错的），然后构建两个子模块，接着就是IR解析，控制信号设置，PC计算，写回数据判断，ECALL处理和周期计数。\n再说注意事项：\n每一条指令都是有写操作的，会对CPU状态产生影响，控制信号的作用主要是控制写操作。而读操作不会影响CPU状态，为了保证单周期需要同时进行所有可能的读操作，并根据控制信号将选出要写入的数据。因此，只要写信号设置正确，任何冗余的操作和读信号都可以放心大胆的写上去。 先整体再具体，先实现根据指令的类型使用Splitter提取出对应的字段比如说rd，imm12等，再按照该类型的通用执行流程设计数据流向。实现完整体之后，再考虑带有非共性的指令的实现，比如说sw，jw。中断相关的指令可以先不具体实现，但一定要先预留信号引脚位。 最上边自带的显示的数据一定要有效，否则不能通过头歌平台的测试，在提交之前最好把用于测评的代码先加载到指令存储器中。 halt是ecall使用的暂停标志，Go是在halt状态下解除暂停的标志，针对ecall指令单独设置多个MUX是必要的。 跳转指令（BNE，JAL等）的立即数是符号扩展左移1位而不是+4相当的2位，这一点比较特殊。 理想流水线 非常无聊的任务，但是是后面的流水线的基石，也需要花比较长的时间去制作四个接口。\n五个阶段需要执行的任务分别是：\nIF：按照规则找出目标PC值，并从指令存储器中取出对应的指令 ID：根据IR生成所有的控制信号和立即数，访问寄存器堆（包含写回，但是写回内容和信号由WB阶段传递回） EX：根据传入的R1和R2或立即数值调用ALU进行计算，以及其他各种计算工作比如跳转语句的PC计算，Ecall显示和暂停计算，跳转是否执行的计算，总之是各种计算中间数值的计算。 MEM：根据计算的地址访问存储，是性能的瓶颈之处，基本上只有lw，sw这样的指令才会真正用上。 WB：计算出要写回寄存器组的数据和是否写回的信号，相比MEM的写操作更为复杂，因为MEM阶段的写指令内容很简单。 理想流水线的核心逻辑是，利用多个寄存器将指令的执行分为五个阶段，从而使得每个周期都能处同时处理不同的指令的一个部分，将时间从5n优化到n+4。在理想流水线的阶段，不需要考虑任何因指令形式导致的错误。所以单纯是增加了四个寄存器接口，使得五个阶段的数据能够对应执行的五条不同的指令而不是同一条指令。\n请为接口留下两个引脚位置，一个是清零，一个是暂停，前者用于后续的改进，后者用于Ecall指令和改进。除此之外，接口的传递原则是，后面的阶段需要使用到的信号和数据就传递，如果只在目前的阶段使用，就不传递。\n关于写操作的问题，存储的写回就不必赘述，因为必做的只有sw指令，写存储信号触发的时候不用像WB阶段进行复杂的数据筛选，直接采用ALU的结果即可，且访存指令之前不存在数据依赖，所以不存在冒险问题。\n而寄存器写回比较复杂，因为涉及到对寄存器组异步写，这会导致对于同一个数据访问的竞争，虽然ID/EX接口能够锁住WB阶段传回的值，但在EX和MEM阶段对应的寄存器写操作和ID阶段的同一个寄存器的读操作显然是冲突的，在尚未写回的时候尝试读很明显是错误的，这是理想流水线的第一个问题。\n第二个问题是分支预测，分支指令的跳转值需要在EX阶段执行（当然也可以在ID阶段添加额外的内容来计算，不过这也是一种改进流水线，不是理想流水线），所以无法直接得出下一条指令从哪里开始。当得到应该跳转的地址时，此时ID段应该就是这个地址，但是由于之前并不能判断是否跳转，只是默认+4，故ID段执行错误，导致分支冒险。\n气泡流水线 对于上述提到的两个问题，气泡流水线的改进非常简单粗暴，那就是插入空指令（气泡）。\n先谈分支预测，这里很简单，EX段决定，那么如果EX段是跳转指令并跳转，那就清空IF/ID，ID/EX两个接口的状态，相当于插入一个气泡，此时状态由IF重新开始传递。从最终效果来看，只有在确定要跳转的时候，才会执行分支气泡插入，导致PC对应指令执行的下一条是跳转后的语句（置零产生的空指令NOP没有写操作因为可以无视）。\n再谈数据冒险，也很简单，如果下一条语句要用到前两条语句的写结果时，就暂停直到写结果被执行。判断的方式就是将EX/MEM段的Rd代号并和ID段的R1和R2代号进行比较，如果相等且不为0号寄存器且EX/MEM段有写信号时则触发数据冒险。\n如果只有MEM段冲突，那么到图中第二列就结束冲突处理了，如果存在EX段冲突，那么到图中第三列才结束冲突处理了，结束冲突处理之后，下一个周期就是正常的全体右移一格，第一格+4。\n以上方式是从EX段的方式进行干预，当然也可以从ID段进行干预，比如将分支跳转的计算提前到ID段来决定是否跳转，这需要额外的运算器。\n重定向流水线 在气泡流水线的解决方案中，插入空气泡的确能够解决问题，但是这样会降低流水线的效率，有没有一种等待更低的方式呢？那就是重定向流水线，将冲突的数据直接从后面的阶段中给出来，减少等待气泡数，当然这里的重定向专指数据重定向。\n数据重定向有两种形式，第一种是EX占用冲突，第二种是MEM占用冲突。这里的冲突又分为寄存器读写冲突和存储器读寄存器读冲突。\n由于MEM和WB阶段不直接利用R1和R2的值，所以这里的“脏读”情况实际上只影响了EX阶段，使ID/EX接口传过来的R1和R2在此种情况下不正确。数据重定向就是纠正R1和R2生成正确的R1和R2用于EX阶段的所有计算，故设计R1R和R2R表示实际的情况。无冲突情况下，R1R=R1，R2R=R2。针对R1R和R2R的多种情况，再设计一个筛选用的掩码R1F和R2F，它们在ID阶段就生成并传递到EX阶段，构建R1F和R2F的条件集合就是对应的情况的判断。\nEX + 存储器读寄存器读冲突，由于EX阶段中值没有被读到，所以需要等待到MEM阶段才能给出，所以需要插入一个气泡，这也是唯一等待的时机，等待之后，EX占用冲突便转为了MEM冲突。 EX + 寄存器读写冲突，在前一个阶段EX计算的结果（实际冲突的数据）传递到了MEM阶段，从MEM中直接获取即可，默认是只有ALU计算结果和JAL，JALR的PC+4结果需要获取。 MEM + 存储器读寄存器读冲突，此时结果设置为RDin，直接按情况筛选。 MEM + 寄存器读写冲突，同情况3，此时结果为RDin，直接按情况筛选。 单级中断 单级中断的在此处的概念是，同时只能处理一个中断，如果同时有多个中断信号源，则按照优先度选择先执行的中断，让其他的中断等待。\n单级中断的实现思路是，每条指令执行完之后，如果有中断信号发出，且目前没有关中断，则关中断，保存下一条语句的PC，加载对应中断处理程序的PC，处理完之后加载回保存的PC，并开中断，清除中断处理信号。\n由于单级中断不存在嵌套处理，所以不需要实现CSRRSI/CSRRCI这两条指令，只需要实现URET指令及其控制信号即可。\n从第一步说起，需要处理中断信号输入，给定的信号发生器如下：\n有两种方式触发，一种是上方的手动触发，一种是下方的在指定周期触发，提交到头歌平台上是需要采用下方，也就是默认的触发方式。在默认触发方式下，中断信号IRX仅会在对应周期为1，在其他周期为0。除了中断信号，还有中断处理信号INTRX，数量和IRX一致，表示当前正在处理的中断序号，并且设置一个总处理信号INTR，表示正在有中断被处理。\n因为中断有排队等待机制，所以需要存储中断信号发送，这里用一个D触发器即可，输入源就是IRX信号，刚好由0-\u0026gt;1-\u0026gt;0可以触发一次写入。当中断处理完之后，由URET指令带来的控制信号发出中断清除信号ClearX，从而清除该中断。中断信号暂存部分如下：\n第二步就是开关中断，这个用一个D触发器实现即可，输入URET和~INTR。\n第三步就是PC的更替，添加一个MEPC存储下一条语句的PC，然后选出对应中断处理程序的入口作为新的下一条语句PC输入到PC中，在URET信号存在的时候，将MEPC作为下一条语句PC输入。\n最后就是ClearX信号生成，这个配合INTRX和URET信号组合即可。\n多级中断 多级中断的中断信息保留，中断入口判断，中断清除和NPC（Next PC）选择模块没有变化。而新增了对CSRRCI/CSRRSI的指令的实现，修改了开关中断，中断优先级比较和MEPC以及中断总处理信号的部分。\n第一步是实现CSRRCI/CSRRSI和开关中断，这两个是连在一起的，开中断的条件变得更加复杂，CSRRSI强制开中断，CSRRCI强制关中断，这两条指令在中断处理程序中调用，一般用于保护现场，防止中断被打断无法恢复，除此之外不会被使用，所以使用时一定在处理中断。而CSRRSI的效果直到CSRRCI才结束，所以需要一个D触发器存储CSRRSI的激活和CSRRCI的反激活。\n第二步是中断优先级比较模块，只有在当前处理的中断INTROn小于要处理的中断INTRX的优先级且开中断时，才触发总中断处理信号INTR。\n最后一部分就是MEPC和INTROn的处理，取而代之，INTR变成了瞬态信号，用于嵌套中断时的现场（PC，INTROn）保存，INTROn具体指出了当前处理的信号标号（2位）。考虑到此时一共会有三种异常信号，所以需要三个寄存器来存储，在INTR或URET信号激活时进行一次更新。这里的处理思路就很简单了，第一层寄存器存储的是当前值，第二层是上一个中断/正常语句的值，第三层是正常语句/0的值。假设按照1-\u0026gt;2-\u0026gt;3的顺序处理中断，那么此时第一层MEPC就是中断处理程序2被打断的下一条语句，INTROn是3，第二层MEPC是中断处理程序1被打断的下一条语句，INTROn是2，第三层MEPC是正常语句被打断的下一条语句，INTROn是1。可能的嵌套结构如下：\n重定向 + 单级中断 这里先复制重定向流水线，再复制单级中断的中断处理的部分，然后将URET改为EX阶段的URET。同时条件重定向的条件加上EX.URET和INTR，最后就是修改EMPC的来源，如果是原来的B型和J型跳转指令，就是计算出来的NPC，如果不是的话，就从前面（IF/ID）的阶段中取。从前面的阶段中取的时候，要分辨是否是连续的URET，如果是那么存储的PC是IF阶段的，反之则是ID阶段的，因此需要一个寄存器存储EX.URET的前态。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/%E6%9D%82%E8%B0%88/hardcoretrain/","summary":"不附带源文件","title":"HUST硬件综合训练"},{"content":"Godot自定义菜单构建 在Godot中，编辑器扩展和在Unity中相比底层的支持更少，从引擎的量级对比上就可以看出。默认的可添加UI控件的位置并不包含左上角和场景、项目等并列的位置，这就导致使用起来不方便的问题。\n另一个问题是，当使用外部编辑器之后，对于EditorScript的运行便无法通过常规的Script-\u0026gt;文件-\u0026gt;执行调用，这样导致如果要频繁地调用简单的编辑器专用脚本，切换时非常麻烦。因此需要采用EditorPlugin的方式来创建，但这样就回到了第一个问题。\n考虑到Godot使用的是构建游戏的所有对象来构建自己的引擎，二者是同源的，Godot的UI也是在启动的时候构建成了一个树状结构，那么我们可以筛查这个UI结构，找到要插入控件的父对象，然后把我们要添加的自定义菜单PopupMenu对象作为孩子插入即可。\n定位语法树 既然语法树是一个树状结构，我们可以通过递归调用的方式获取并输出每一个节点。获取根节点的接口是EditorInterface.Singleton.GetBaseControl()，通过依次递归调用，得到了从根节点到目标位置的语法树（Godot版本4.4.1 NET.，不保证稳定）：\n@Panel@14 (Panel) @VBoxContainer@15 (VBoxContainer) @EditorTitleBar@16 (HBoxContainer) @MenuBar@103 (MenuBar) 场景 (PopupMenu) @PopupMenu@4924 (PopupMenu) @PopupMenu@4930 (PopupMenu) 项目 (PopupMenu) @PopupMenu@4941 (PopupMenu) CSharpTools (PopupMenu) @PopupMenu@14113 (PopupMenu) 调试 (PopupMenu) 编辑器 (PopupMenu) @PopupMenu@4954 (PopupMenu) @PopupMenu@4960 (PopupMenu) 帮助 (PopupMenu) 根据Godot的API：\n使用@EditorTitleBar@*这样的方式可以找到最终的位置，此时调用AddChild方法添加一个PopedMenu对象即可。\n添加可执行项 现在离成功执行脚本只差一步，只有向PopupMenu中添加元素才能有效果。这一点很简单，调用AddItem接口，传递选项显示内容和唯一ID即可做到。\n关于处理菜单选择，PopupMenu通过IdPressed信号来接收操作，该信号传递一个类型为long的id，表示对应的选项被按下，这个时候需要自己处理该怎么操作，比如维护一个回调Dictionary。信号处理函数如下：\nprivate Dictionary\u0026lt;long, Action\u0026gt; _menuCallbacks = new(); private void OnMenuItemPressed(long id) { if (_menuCallbacks.TryGetValue(id, out Action action)) action?.Invoke(); } 热重载 使用C#比较麻烦的一点是，任何改动如果要生效都需要重新Build，这就涉及到一个热重载的问题。我做了一个简易的实验，在构造函数和 _ExitTree中提供字段的输出，在 _EnterTree中进行字段的设置，得到了以下的结果：\n其中True和False输出的是是否为空。\n根据实验可以得到以下结论：\n当EditorPlugin在启用的情况下Build，那么这个对象将会被销毁并重新构建，同时会复制之前所有的字段值，如果是引用对象也会复制原来的引用。 Build的过程中不会触发 _EnterTree函数和 _ExitTree函数，但是会调用构造函数。 Build的过程中不应该预设UI字段仍然有效，所以在_ExitTree函数中应该重新FindChild。 妥协 因此，鉴于引用是直接复制的，那么要求就是向管理目录的对象中添加的回调一定是static的，即不包含实际调用的信息，不包含对象的成员。以下面的代码为例，ScanDeployAsset是一个static函数，具体内容省略。\npublic partial class DeployScanner : EditorPlugin { private static readonly string itemName = \u0026#34;扫描可部署资产\u0026#34;; public override void _EnterTree() { GetTree().ProcessFrame += Register; } public override void _ExitTree() { ProjectTopMenu.Instance?.RemoveItem(itemName); } public void Register() { GetTree().ProcessFrame -= Register; ProjectTopMenu.Instance?.AddItem(itemName, ScanDeployAsset); } } ","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/godot%E6%90%AC%E8%BF%90/godot-uitree/","summary":"Godot基础编辑器拓展","title":"Godot自定义菜单"},{"content":"RMDB系统文档 rmdb.cpp rmdb.cpp定义了服务端的流程，除了端口连接的部分，每一个连接都会打开一个循环，循环每次接收客户端的一条输入语句，判断特殊语句之后，将视为sql文件，经过parse、analyze、plan、execute四个阶段进行执行。\n同时rmdb.cpp为每一条语句生成一个上下文，并按照是否为单挑语句设置事务。\n由于客户端可以视作简单的字符串发送接收器，因此全部的事务由rmdb.cpp负责执行，模块的导入都在rmdb.cpp中完成。\n系统定义 前端 RMDB系统的前端负责接收SQL语句，生成对应的Plan对象，并将这些对象传递给后端进行实际的执行。\nParser Parser负责将SQL语句转化为抽象语法树，类似于语义分析。使用Flex和Bison插件来完成从字符串到抽象语法树的转化，并得到一个根节点。Flex和Bison通过全局的变量来传递：\nstd::shared_ptr\u0026lt;TreeNode\u0026gt; ast::parse_tree; 因此需要上锁，调用的情境如下：\nbool finish_analyze = false; pthread_mutex_lock(buffer_mutex); YY_BUFFER_STATE buf = yy_scan_string(data_recv); if (yyparse() == 0) { if (ast::parse_tree != nullptr) { try { std::shared_ptr\u0026lt;Query\u0026gt; query = analyze-\u0026gt;do_analyze(ast::parse_tree); yy_delete_buffer(buf); finish_analyze = true; pthread_mutex_unlock(buffer_mutex); } } } if (finish_analyze == false) { yy_delete_buffer(buf); pthread_mutex_unlock(buffer_mutex); } Flex插件对应src/parser/lex.l文件，里面定义了关键字匹配规则，决定了一条语句将会被提取出怎么样的语素(Token)。\nBison插件对应src/parser/yacc.y文件，里面定义了语法规则，决定了语素以什么样的顺序组织是合法的以及如何将一个语素序列转化为一个抽象语法树。\nast::TreeNode ast::TreeNode是语法树的抽象节点，任何节点继承于此。节点的类型本身就是一种信息，同时节点的字段提供了节点的详细信息。\n节点的定义通过SemValue这个结构体与Bison插件进行映射，成员的名称作为Bison插件中的类型指代，而成员的类型是Bison的语法对象最终构建的类型(如在Bison中，sv_int代表着int节点)，每一条语法规则都有自己的类型。\nstruct SemValue { int sv_int; float sv_float; std::string sv_str; bool sv_bool; std::vector\u0026lt;std::string\u0026gt; sv_strs; std::shared_ptr\u0026lt;TreeNode\u0026gt; sv_node; SvCompOp sv_comp_op; std::shared_ptr\u0026lt;Value\u0026gt; sv_val; std::vector\u0026lt;std::shared_ptr\u0026lt;Value\u0026gt;\u0026gt; sv_vals; std::shared_ptr\u0026lt;Col\u0026gt; sv_col; std::vector\u0026lt;std::shared_ptr\u0026lt;Col\u0026gt;\u0026gt; sv_cols; }; #define YYSTYPE ast::SemValue Query \u0026amp; Plan Query和Plan是从解析的语法树到实际执行的Executor之间的中间产物，负责提取SQL语句的实际功能并按需分组。\nQuery Query是对SQL语法树的统一的表示，通过Analyze对象生成，接口是：\nstd::shared_ptr\u0026lt;Query\u0026gt; Analyze::do_analyze(std::shared_ptr\u0026lt;ast::TreeNode\u0026gt; root); Query对象包含了根节点本身，这些根节点用于在创建Plan的时候提供语句类型以作出区别。\nAnalyze Analyze主要用于分析DML和Load语句，检验SQL语句中的语义错误，比如不存在的列，二义性的列，并从Ast语法树的结构中提取出统一的，易于利用的信息。对于其它语句，Analyze则什么也不做，直接传递Ast语法树到Plan生成部分。\nPlan Plan及其继承类是对Query进行进一步优化得到的结果，且不再包含Ast节点和Query对象引用，在数据存储上尽量减少了冗余。从结构上看，它和最终生成的Executor十分类似，可以视作是各种Excutor生成的初始化条件对象。\nPlan生成的接口如下，其中DML语句的详细生成由Planner对象进行。\nstd::shared_ptr\u0026lt;Plan\u0026gt; Optimizer::plan_query(std::shared_ptr\u0026lt;Query\u0026gt; query) std::shared_ptr\u0026lt;Plan\u0026gt; Planner::do_planner(std::shared_ptr\u0026lt;Query\u0026gt; query); Planner Planner负责DML描述语句执行的层级结构，特别是对于复杂的Select语句，Planner需要进行语义上的优化来减少Select中间体的大小，元组数目来提高效率。\n在Task5中实现的规则有：\n选择下移：对于单个表的Scan方案，将等号右边为数值，左边为该表属性的条件下放到ScanPlan中，以减少中间体数目。 投影下移：对于单个表的Scan方案，预先进行一次投影的封装，保留最后选择的属性、用于条件判断和分组的属性，其余属性全部去除，以减少S中间体大小。 连接排序：对于表之间的Join方案，首先通过RmFileHandle来依次读取表中元组数并排序，按照从小到大的顺序决定连接的顺序，以减少中间体数目，并尽可能的下移连接条件。 在决赛中添加的规则有：\n条件替换：如果出现表之间的属性相等条件(A.B = C.D)和其中一个属性的等值条件(C.D = X)，可以去掉等值条件将属性相等条件通过代入法替换成一个等值条件(A.B = X)，从而使本来无法通过索引扫描的表变为索引扫描。 后端 RMDB系统的后端负责实际执行语句，并写入执行结果以供client_handler反送回客户端。\nPortal Portal是接收Plan构建Executor并实际执行语句的中间体，是连接抽象层和实现层之间的桥梁。Portal的接口是：\nstd::shared_ptr\u0026lt;PortalStmt\u0026gt; start(std::shared_ptr\u0026lt;Plan\u0026gt; plan, Context *context, TransactionManager *txn_manager); void run(std::shared_ptr\u0026lt;PortalStmt\u0026gt; portal, QlManager *ql, txn_id_t *txn_id, Context *context); start用于生成根据Plan生成PortalStmt，对于DML语句来说还伴随着Executor的生成。而run函数则执行PortalStmt，根据种类来决定使用哪一个执行模块。大致分为DML、DDL、事务，分别对应ExecutionManager，SmManager，TransactionManager。\n对于DML语句，首先判断语句种类，根据不同的语句构建不同的Executor：\nInsert语句：直接构建InsertExecutor。 Delete/Update语句：根据条件和表名构建SeqScanExecutor/IndexScanExecutor，执行一轮之后按照获取的Rid集合构建DeleteExecutor/UpdateExecutor。 Select语句：照着Plan的结构翻译即可，Select用上的每一种Plan都能找到对应Executor。 对于DDL语句，直接调用SmManager对应的创建/删除/查询函数即可。\n对于事务语句，直接调用TransactionManager的abort，commit函数即可。\nSmManager SmManager是RMDB系统的底层管理器，任何底层操作都要通过SmManger为中介来执行，而任何组件之间的调用都需要SmManager提供指针，任何和表/索引元数据的获取都需要SmManager提供，因此SmManager可以说是数据库的中枢控制器。\nSmManager包含了BufferPoolManager、DiskManager、IndexManager和RmManager。后二者用于对索引和表进行实际的文件操作，而数据库级别的操作由SmManager内部调用命令行语句完成。\nStorage 存储模块主要负责将提供程序运作时的页，并将程序的修改同步到硬盘以持久化。其他模块在运作的时候，是不需要关注存储实现的细节，只需要提出获取页、开闭文件、创建文件的要求，由存储模块实际执行。\nPage Page（页）是磁盘文件最基本的存储单位，表和索引文件都以Page的形式存储并以页的形式进行访问。页本身的序号具有意义，因此无论页处于何处，以何种形式处理，都可以通过唯一的编号PageId来定位。\nPageId指出了是哪一个表（索引）的哪一个Page，可以通过计算式 PAGE_SIZE * PageId.pageno 来方便的定位Page的起点。Page本身不解释其中的内容的含义，只有通过FileHandle进行封装才能执行有意义的页操作。\nDiskManager DiskManager负责开闭文件以及以Page为单位进行读写，使用的是C底层文件流实现以及对系统终端的调用。\nDiskManager的操作是最基本的操作，任何文件相关操作都需要通过调用BufferPoolManager来具体的实现。\n只有绕开BufferPoolManager直接调用disk_manager的情况下不用考虑pin和unpin的问题。\nBufferPoolManager 缓冲池是负责向上层提供具体页并接收指令写回具体页的模块，是对内存中Page进行管理的对象。\n缓冲池可以进行固定页和解绑页，被固定的页不会被纳入替换的列表中。而未被固定的页可以被访问，但是当需要读取新页而缓冲池已满的时候，通过LRU的算法从未被固定的页中选取一份替换，若为脏页则先写回硬盘，而对页的读写操作实际还是由DiskManager执行。\n缓冲池中pin和unpin就像new和delete一样，需要配对。如果缓冲池中所有页面被固定而此时又有对缓冲池中没有的页进行请求，那么这个请求失败，事务回滚。因此，一旦不需要页的内容，就要及时unpin，减少pin_count。new_page和fetch_page两个函数会增加pin_count，只有也只应该有FileHandle调用了这些方法。\nPage* BufferPoolManager::fetch_page(PageId page_id); Page* BufferPoolManager::new_page(PageId* page_id); Pin和Unpin应该由FileHandle成对地封装在接口中以保证没有页泄漏，尽管目前在planner和scan文件中PageHandle被作为返回值供调用者使用，更合理的做法是提供外部接口直接满足其他对象的需求，而不是返回一个PageHandle将Unpin的职责转移给调用方。\nRmManager RmManager是对表文件进行统一管理的对象，负责表文件的创建、销毁、打开和关闭。打开的过程获得一个RmFileHandle，其中包含了RmFileHeader。除了在planner中为了根据元组数量优化连接顺序调用了RmManager的函数，其他时候都是由SmManager对其进行封装并调用，这一点应该上升到强制通过SmManager调用。\nRmFileHandle 文件句柄是对于一个已经打开的文件，能够对其进行读写的中间对象，分为索引句柄和表句柄，RmFileHandle是表句柄。RmFileHandle包含RmFileHeader，其中包含了表的元数据，这些是不可修改的，且存放在表文件的0号页。\nRmFileHandle支持按Rid进行操作如update_record，delete_record，也可以通过页号获取页句柄RmPageHandle。RmPageHandle是对表中的具体页进行管理的对象，通过调用BufferPoolManager接口获取Page并封装。\nRmPageHandle RmPageHandle包含了页的信息以及原始数据，基本上只在遍历的时候用上，使用其中的slot来遍历页并获取下一张页的信息。一般用于遍历或者计算元组数量使用，如果要修改某个页的内容，请通过RmFileHandle提供的接口来进行。\n每一个RmPage分为三个部分RmPageHeader、Slot、Data，分别保存了页的元数据，槽位bitmap，元组数据。\nRmRecord RmRecord是元组在内存中的存在形式，元组本身只有data这一部分，也就是纯粹存储信息的一段紧密01数据，而通过赋予size，allocated信息使得其能够被赋予使用意义并有效管理。但修改一个从RmFileHandle得来的RmRecord对象或者其指针引用并不会将改变写到内存中，因为RmRecord的几乎所有构造方式都是复制数据。\nRmScan RmScan是实际对记录进行扫描的对象，每次获得一个Rid的时候，都会先检查其版本记录，根据最新可见版本是否存在，是否删除决定元组是否可见。\n在判断可见性的过程中如果要回溯的话会首先访问一次版本记录，于是将此次记录先缓存，以免在Next()函数调用时再进行一次回溯。同时改进原本的std::vector存放旧列值，以及哪些列修改的属性，直接存放元组的01内容效率更高。\nIxManager IxManager和RmManager类似，是对索引文件进行底层管理的对象，相比而言增加了一些判断函数用于实际执行中选择索引。\nIxFileHandle IxFileHandle是对于索引文件而言的，支持通过key的方式查询唯一性和调整索引结构。IxFileHandle包含IxFileHeader，其中包含了索引的元数据，这些是不可修改的，且存放在索引文件的0号页。每一个节点存放了若干个键，在叶节点中存放着对应的元组Rid，也是索引实际存放的内容，即按照key的顺序在B+中按树叶节点遍历的位置存放元组的唯一标识。\n除了fetch_node之外的所有未被外部调用的接口都满足Pin和Unpin成对，在别的分支有过修改，将唯一在IxScan中的调用搬到IxFileHandle内部实现，最终满足外部接口不返回IxNodeHandle，缓冲池不泄露。\nIxNodeHandle IxNodeHandle实际上和RmPageHandle一样，包含了页的信息以及原始数据，但是由于索引文件中每一个页都是一个B+树节点，因此得名NodeHandle。IxNodeHandle支持查询和插入删除等功能，修改力度较小。\nIxNodeHandle一样拥有自己的三部分数据：IxPageHeader、keys、rids，分别保存了页的元数据，键，元组的Rid值。\nIxScan IxScan继承自RmScan，IxScan不同的作用就是按照给定的Iid开始和终点遍历叶节点，从而缩小Rid的范围。也就是说，RmScan每次Rid自增的设定由IxScan升级为在索引中查找下一个符合某些条件的Rid，而根据Rid获取元组的功能依旧没有改变，所以可以复用部分代码。\nExecutor LoadData LoadData执行器采用快速读取的方式从csv文件中逐行转化为RmRecord。首先会在主线程中按行读取string并放到一个集合中，每当这个集合内容达到上限时，就分配一个任务，并向RmFileHandle预分配一个界面。读取完所有的行后，会通过多线程来领取并完成给定的任务，实际是将string处理并插入到对应任务的预分配页面中。\n在插入到表文件之后，需要收集每一个索引的每一个键值对，这通过获取RmFileManager的所有Page进行，然后进行排序，调用索引的bulk_load来一个一个索引的加载。使用bulk_load的时候，会先建立素有叶子节点层，然后递归的向上建立节点。\nFastCount FastCount执行器直接从对应表中的文件头中读取一个记录元组数量的变量，然后构建一个RmRecord返回，而在插入和删除的时候负责维护这个值。\nSort Sort执行器先遍历一轮子Executor获取所有元组，然后进行一次Sort，最后一个一个按顺序返回即可。\nAggregation Aggreation执行器在beginTuple中先遍历一轮子Executor获取所有元组，然后按照分组的字段进行分类，最后依次输出。\nProjection Projection执行器直接对于子Executor得到的RmRecord进行部分复制，从而做到减小元组大小，筛选出目标属性。\nInsert Insert执行器先根据传入的变量构建一个Rmrecord，然后直接调用RmFileHandle执行插入，并且当场插入索引。\nSeqScan SeqScan执行器构建了一个RmScan对象，通过其next、end、Next接口来分别步进、判断结束和获取RmRecord，对于获取到的RmRecrod，执行器需要判断其是否符合筛选条件，如果需要上锁，会在扫描到一条符合的元组的时候就对其上锁，考虑到可能要排队，排队的过程中肯定有别的事务修改了元组，因此获取锁之后还需要进行再验证，即再次判断元组是否符合条件。只有在SeqScan是用于收集Update和Delete的Rid时才会设置上锁选项。\n在实际的Tpcc测试中，由于针对语句进行了优化，SeqScan并没有实际被用上。\nIndexScan IndexScan执行器构建了一个IxScan对象，同样通过其进行实际的探查、获取。在构建之前，需要根据使用的索引和条件来生成key的范围，通过两次查询获取起点和终点的Iid并传递给IxScan。其余的过程和SeqScan类似。\n在提交分支之外有一处优化，如果按照索引的属性顺序排列有连续的等值条件或者不等值条件（不等值条件一定是连续的最后一个），那么得到的元组一定满足这些条件，那么不需要再次验证，可以从待验证的条件中删去。\nNestedLoopJoin NestedLoopJoin执行器先遍历一边右孩子，找到满足连接条件的元组拼接并返回，再让左孩子步进，直到左孩子结束。\nLimit Limit执行器通过简单的计数，在遍历完子查询的输出或者达到限制后宣告end来进行数量限制。\nDelete Delete执行器在获取到Rid集合之后，直接构建一个带删除标记的TupleHeader写回对应的Rid元组位置，不当场删除索引。\nUpdate Update执行器在获取到Rid集合之后，直接构建一个完整RmRecord写回到对应的Rid位置，非事务模式下不涉及索引。\nTransaction 时间戳 全局时间戳是一个每次被访问就会+1的变量，在开启一个事务时以及结束一个事务时都会访问全局时间戳，这样可以保证时间轴的运转是一直向前的，不存在时间戳相同引起的复杂判断。同时TransactionManager有两个map：\nstd::unordered_map\u0026lt;timestamp_t, txn_id_t\u0026gt; TransactionManager::commit_map; std::unordered_map\u0026lt;txn_id_t, timestamp_t\u0026gt; TransactionManager::commit_time; 这两个map用于通过相互转换结束时间戳和获取事务ID，结合函数CheckIfCommitted来判断事务的性质。\n持久化UndoLog 每个事务的UndoLog存储的是这个事务修改的元组本来的样貌和时间，当事务完成之后，Transaction对象不再存在，但是UndoLog仍然需要被保存，以供版本链的回溯。利用map：\nstd::unordered_map\u0026lt;txn_id_t, std::vector\u0026lt;UndoLog\u0026gt;\u0026gt; TransactionManager::txn_undos; 可以从内存中读取过去的UndoLog。UndoLog的保存规则是，谁覆盖谁保留原版本。\n从内存卸除过时事务 反向map和UndoLog不能无限的存储，因为内存是有限制的。一个结束事务可以被卸除的充分条件是：\n如果是提交的，在此事务提交之前开始的所有事务都已经结束。之后开启的任何事务访问到的版本一定不会早于此事务修改的，而UndoLog中的版本是更早的版本，故可以删除。所以需要维护一个当前最早开始的事务ID，由于事务开始时间和事务ID大小性一致，在每次提交的时候删除掉当前最早ID之前的所有事务记录。\n如果是中止的，这个事务的所有UndoLog被恢复，所以不存在影响。\n在此维护一个est变量表示最早开始的活跃事务，任何事务未结束的事务的元组ts都大于等于est对应事务的start_ts。在此之前提交的事务的提交信息也可以卸除了。\n判断一个时间戳对应的事务是否提交的判据变为了：commit_map中存在时间戳或者时间戳小于est的start_ts。\nMVCC\u0026amp;Lock TupleHeader TupleHeader是附加在每一个元组属性上的字段，\n无锁读 MVCC的精髓就是无锁读，在快照隔离的情况下，只需要验证时间戳就可以获取可见性。\n有锁写 按照冲突直接abort的要求，如果一个事务先修改了元组T1，而另一个后来的事务也向修改T1，那么会直接abort并会一直发生直到第一个事务结束。也就是说，只有这个事务在第一个事务结束后再开始才能不abort地修改。\n上述存在的问题是：\n重做浪费了很多资源，可能出现了资源抢占的现象 难以把握重做的频率，导致第一个事务结束和第二个事务不冲突的那一次的开始时间之间有间隙 所以考虑加锁，当后来的事务试图修改同一个元组时，需要等待已有的锁释放，之后再次检验加锁的元组是否满足需求，若不满足，则取消更改此元组即可。这里的效果是等效的。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/linux%E6%90%AC%E8%BF%90/rmdbdoc/","summary":"写都写了就发上来罢","title":"数据库系统能力大赛总结文档"},{"content":"基本格式 \\e[0m 清除当前所有应用样式 \\e[1m 设置终端输出样式1 \\e[1;2m 组合终端输出样式1和2\n样式列表 ","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/linux%E6%90%AC%E8%BF%90/colorterminal/","summary":"留档用","title":"彩色终端输出"},{"content":"戳泡泡游戏 maimai w55，无牌子\nArcaea 12.25\nChunithm 15.30\nDJMax V 4b 4700，兴趣来了打一打\n范式起源 132.8，没大氪，歌比较少\n另外，买了Deemo II的白金车票和喵塞克的小伙伴，但是基本上没怎么打过\n总体来说中等水平吧，下不去上不来，还有一个目标就是收集所有PC端的音游。\nJ/ARPG 首先端上来的是如龙系列，为什么想玩是因为maimai中有一首很经典的Outlaws lullaby。然后找到了如龙，打玩0代之后就停不下来了，接着体验了审判之眼，审判之逝。\n然后就是仁王系列，毫无疑问是神史参半的，除了美术和地图设计之外都挺好，剧情会让人产生好奇心从而去了解。\n类银河恶魔城 首推Rabiribi和Tevi，虽然有这样那样的瑕疵，但是完美的画风+弹幕爽。 再推终焉系列，目前出了Lilies和Magnolia，同样我认为画风、音乐和剧情很棒，至于游戏内容，属于及格线边缘徘徊的程度，但还没到大份的程度。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/%E6%9D%82%E8%B0%88/gametalking/","summary":"报菜名时间","title":"成分"}]