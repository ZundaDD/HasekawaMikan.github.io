[{"content":"任务概览 简单来说，就是先构建一个单周期RISC-V CPU，然后基于此加入中断和流水线功能，最终将二者合并在一起，所以作为根基的单周期CPU的设计一定要恰当，不然之后改进的时候就会很麻烦。每个人都有自己的四条专属的指令，建议在设计单周期CPU时就做完，以免之后每一个任务都额外去补充实现。\n以上是实现流程，红色为必做，蓝色为选作，完成图中所有内容后，理论上能拿到实践部分的满分。\n单周期RISC-V 先说流程，首先是填表（表的生成那一页的红色字体是自带的，不是错的），然后构建两个子模块，接着就是IR解析，控制信号设置，PC计算，写回数据判断，ECALL处理和周期计数。\n再说注意事项：\n每一条指令都是有写操作的，会对CPU状态产生影响，控制信号的作用主要是控制写操作。而读操作不会影响CPU状态，为了保证单周期需要同时进行所有可能的读操作，并根据控制信号将选出要写入的数据。因此，只要写信号设置正确，任何冗余的操作和读信号都可以放心大胆的写上去。 先整体再具体，先实现根据指令的类型使用Splitter提取出对应的字段比如说rd，imm12等，再按照该类型的通用执行流程设计数据流向。实现完整体之后，再考虑带有非共性的指令的实现，比如说sw，jw。中断相关的指令可以先不具体实现，但一定要先预留信号引脚位。 最上边自带的显示的数据一定要有效，否则不能通过头歌平台的测试，在提交之前最好把用于测评的代码先加载到指令存储器中。 halt是ecall使用的暂停标志，Go是在halt状态下解除暂停的标志，针对ecall指令单独设置多个MUX是必要的。 跳转指令（BNE，JAL等）的立即数是符号扩展左移1位而不是+4相当的2位，这一点比较特殊。 理想流水线 非常无聊的任务，但是是后面的流水线的基石，也需要花比较长的时间去制作四个接口。\n五个阶段需要执行的任务分别是：\nIF：按照规则找出目标PC值，并从指令存储器中取出对应的指令 ID：根据IR生成所有的控制信号和立即数，访问寄存器堆（包含写回，但是写回内容和信号由WB阶段传递回） EX：根据传入的R1和R2或立即数值调用ALU进行计算，以及其他各种计算工作比如跳转语句的PC计算，Ecall显示和暂停计算，跳转是否执行的计算，总之是各种计算中间数值的计算。 MEM：根据计算的地址访问存储，是性能的瓶颈之处，基本上只有lw，sw这样的指令才会真正用上。 WB：计算出要写回寄存器组的数据和是否写回的信号，相比MEM的写操作更为复杂，因为MEM阶段的写指令内容很简单。 理想流水线的核心逻辑是，利用多个寄存器将指令的执行分为五个阶段，从而使得每个周期都能处同时处理不同的指令的一个部分，将时间从5n优化到n+4。在理想流水线的阶段，不需要考虑任何因指令形式导致的错误。所以单纯是增加了四个寄存器接口，使得五个阶段的数据能够对应执行的五条不同的指令而不是同一条指令。\n请为接口留下两个引脚位置，一个是清零，一个是暂停，前者用于后续的改进，后者用于Ecall指令和改进。除此之外，接口的传递原则是，后面的阶段需要使用到的信号和数据就传递，如果只在目前的阶段使用，就不传递。\n关于写操作的问题，存储的写回就不必赘述，因为必做的只有sw指令，写存储信号触发的时候不用像WB阶段进行复杂的数据筛选，直接采用ALU的结果即可，且访存指令之前不存在数据依赖，所以不存在冒险问题。\n而寄存器写回比较复杂，因为涉及到对寄存器组异步写，这会导致对于同一个数据访问的竞争，虽然ID/EX接口能够锁住WB阶段传回的值，但在EX和MEM阶段对应的寄存器写操作和ID阶段的同一个寄存器的读操作显然是冲突的，在尚未写回的时候尝试读很明显是错误的，这是理想流水线的第一个问题。\n第二个问题是分支预测，分支指令的跳转值需要在EX阶段执行（当然也可以在ID阶段添加额外的内容来计算，不过这也是一种改进流水线，不是理想流水线），所以无法直接得出下一条指令从哪里开始。当得到应该跳转的地址时，此时ID段应该就是这个地址，但是由于之前并不能判断是否跳转，只是默认+4，故ID段执行错误，导致分支冒险。\n气泡流水线 对于上述提到的两个问题，气泡流水线的改进非常简单粗暴，那就是插入空指令（气泡）。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/%E6%9D%82%E8%B0%88/hardcoretrain/","summary":"不附带源文件","title":"HUST硬件综合训练"},{"content":"Godot自定义菜单构建 在Godot中，编辑器扩展和在Unity中相比底层的支持更少，从引擎的量级对比上就可以看出。默认的可添加UI控件的位置并不包含左上角和场景、项目等并列的位置，这就导致使用起来不方便的问题。\n另一个问题是，当使用外部编辑器之后，对于EditorScript的运行便无法通过常规的Script-\u0026gt;文件-\u0026gt;执行调用，这样导致如果要频繁地调用简单的编辑器专用脚本，切换时非常麻烦。因此需要采用EditorPlugin的方式来创建，但这样就回到了第一个问题。\n考虑到Godot使用的是构建游戏的所有对象来构建自己的引擎，二者是同源的，Godot的UI也是在启动的时候构建成了一个树状结构，那么我们可以筛查这个UI结构，找到要插入控件的父对象，然后把我们要添加的自定义菜单PopupMenu对象作为孩子插入即可。\n定位语法树 既然语法树是一个树状结构，我们可以通过递归调用的方式获取并输出每一个节点。获取根节点的接口是EditorInterface.Singleton.GetBaseControl()，通过依次递归调用，得到了从根节点到目标位置的语法树（Godot版本4.4.1 NET.，不保证稳定）：\n@Panel@14 (Panel) @VBoxContainer@15 (VBoxContainer) @EditorTitleBar@16 (HBoxContainer) @MenuBar@103 (MenuBar) 场景 (PopupMenu) @PopupMenu@4924 (PopupMenu) @PopupMenu@4930 (PopupMenu) 项目 (PopupMenu) @PopupMenu@4941 (PopupMenu) CSharpTools (PopupMenu) @PopupMenu@14113 (PopupMenu) 调试 (PopupMenu) 编辑器 (PopupMenu) @PopupMenu@4954 (PopupMenu) @PopupMenu@4960 (PopupMenu) 帮助 (PopupMenu) 根据Godot的API：\n使用@EditorTitleBar@*这样的方式可以找到最终的位置，此时调用AddChild方法添加一个PopedMenu对象即可。\n添加可执行项 现在离成功执行脚本只差一步，只有向PopupMenu中添加元素才能有效果。这一点很简单，调用AddItem接口，传递选项显示内容和唯一ID即可做到。\n关于处理菜单选择，PopupMenu通过IdPressed信号来接收操作，该信号传递一个类型为long的id，表示对应的选项被按下，这个时候需要自己处理该怎么操作，比如维护一个回调Dictionary。信号处理函数如下：\nprivate Dictionary\u0026lt;long, Action\u0026gt; _menuCallbacks = new(); private void OnMenuItemPressed(long id) { if (_menuCallbacks.TryGetValue(id, out Action action)) action?.Invoke(); } 热重载 使用C#比较麻烦的一点是，任何改动如果要生效都需要重新Build，这就涉及到一个热重载的问题。我做了一个简易的实验，在构造函数和 _ExitTree中提供字段的输出，在 _EnterTree中进行字段的设置，得到了以下的结果：\n其中True和False输出的是是否为空。\n根据实验可以得到以下结论：\n当EditorPlugin在启用的情况下Build，那么这个对象将会被销毁并重新构建，同时会复制之前所有的字段值，如果是引用对象也会复制原来的引用。 Build的过程中不会触发 _EnterTree函数和 _ExitTree函数，但是会调用构造函数。 Build的过程中不应该预设UI字段仍然有效，所以在_ExitTree函数中应该重新FindChild。 妥协 因此，鉴于引用是直接复制的，那么要求就是向管理目录的对象中添加的回调一定是static的，即不包含实际调用的信息，不包含对象的成员。以下面的代码为例，ScanDeployAsset是一个static函数，具体内容省略。\npublic partial class DeployScanner : EditorPlugin { private static readonly string itemName = \u0026#34;扫描可部署资产\u0026#34;; public override void _EnterTree() { GetTree().ProcessFrame += Register; } public override void _ExitTree() { ProjectTopMenu.Instance?.RemoveItem(itemName); } public void Register() { GetTree().ProcessFrame -= Register; ProjectTopMenu.Instance?.AddItem(itemName, ScanDeployAsset); } } ","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/godot%E6%90%AC%E8%BF%90/godot-uitree/","summary":"Godot基础编辑器拓展","title":"Godot自定义菜单"},{"content":"RMDB系统文档 rmdb.cpp rmdb.cpp定义了服务端的流程，除了端口连接的部分，每一个连接都会打开一个循环，循环每次接收客户端的一条输入语句，判断特殊语句之后，将视为sql文件，经过parse、analyze、plan、execute四个阶段进行执行。\n同时rmdb.cpp为每一条语句生成一个上下文，并按照是否为单挑语句设置事务。\n由于客户端可以视作简单的字符串发送接收器，因此全部的事务由rmdb.cpp负责执行，模块的导入都在rmdb.cpp中完成。\n系统定义 前端 RMDB系统的前端负责接收SQL语句，生成对应的Plan对象，并将这些对象传递给后端进行实际的执行。\nParser Parser负责将SQL语句转化为抽象语法树，类似于语义分析。使用Flex和Bison插件来完成从字符串到抽象语法树的转化，并得到一个根节点。Flex和Bison通过全局的变量来传递：\nstd::shared_ptr\u0026lt;TreeNode\u0026gt; ast::parse_tree; 因此需要上锁，调用的情境如下：\nbool finish_analyze = false; pthread_mutex_lock(buffer_mutex); YY_BUFFER_STATE buf = yy_scan_string(data_recv); if (yyparse() == 0) { if (ast::parse_tree != nullptr) { try { std::shared_ptr\u0026lt;Query\u0026gt; query = analyze-\u0026gt;do_analyze(ast::parse_tree); yy_delete_buffer(buf); finish_analyze = true; pthread_mutex_unlock(buffer_mutex); } } } if (finish_analyze == false) { yy_delete_buffer(buf); pthread_mutex_unlock(buffer_mutex); } Flex插件对应src/parser/lex.l文件，里面定义了关键字匹配规则，决定了一条语句将会被提取出怎么样的语素(Token)。\nBison插件对应src/parser/yacc.y文件，里面定义了语法规则，决定了语素以什么样的顺序组织是合法的以及如何将一个语素序列转化为一个抽象语法树。\nast::TreeNode ast::TreeNode是语法树的抽象节点，任何节点继承于此。节点的类型本身就是一种信息，同时节点的字段提供了节点的详细信息。\n节点的定义通过SemValue这个结构体与Bison插件进行映射，成员的名称作为Bison插件中的类型指代，而成员的类型是Bison的语法对象最终构建的类型(如在Bison中，sv_int代表着int节点)，每一条语法规则都有自己的类型。\nstruct SemValue { int sv_int; float sv_float; std::string sv_str; bool sv_bool; std::vector\u0026lt;std::string\u0026gt; sv_strs; std::shared_ptr\u0026lt;TreeNode\u0026gt; sv_node; SvCompOp sv_comp_op; std::shared_ptr\u0026lt;Value\u0026gt; sv_val; std::vector\u0026lt;std::shared_ptr\u0026lt;Value\u0026gt;\u0026gt; sv_vals; std::shared_ptr\u0026lt;Col\u0026gt; sv_col; std::vector\u0026lt;std::shared_ptr\u0026lt;Col\u0026gt;\u0026gt; sv_cols; }; #define YYSTYPE ast::SemValue Query \u0026amp; Plan Query和Plan是从解析的语法树到实际执行的Executor之间的中间产物，负责提取SQL语句的实际功能并按需分组。\nQuery Query是对SQL语法树的统一的表示，通过Analyze对象生成，接口是：\nstd::shared_ptr\u0026lt;Query\u0026gt; Analyze::do_analyze(std::shared_ptr\u0026lt;ast::TreeNode\u0026gt; root); Query对象包含了根节点本身，这些根节点用于在创建Plan的时候提供语句类型以作出区别。\nAnalyze Analyze主要用于分析DML和Load语句，检验SQL语句中的语义错误，比如不存在的列，二义性的列，并从Ast语法树的结构中提取出统一的，易于利用的信息。对于其它语句，Analyze则什么也不做，直接传递Ast语法树到Plan生成部分。\nPlan Plan及其继承类是对Query进行进一步优化得到的结果，且不再包含Ast节点和Query对象引用，在数据存储上尽量减少了冗余。从结构上看，它和最终生成的Executor十分类似，可以视作是各种Excutor生成的初始化条件对象。\nPlan生成的接口如下，其中DML语句的详细生成由Planner对象进行。\nstd::shared_ptr\u0026lt;Plan\u0026gt; Optimizer::plan_query(std::shared_ptr\u0026lt;Query\u0026gt; query) std::shared_ptr\u0026lt;Plan\u0026gt; Planner::do_planner(std::shared_ptr\u0026lt;Query\u0026gt; query); Planner Planner负责DML描述语句执行的层级结构，特别是对于复杂的Select语句，Planner需要进行语义上的优化来减少Select中间体的大小，元组数目来提高效率。\n在Task5中实现的规则有：\n选择下移：对于单个表的Scan方案，将等号右边为数值，左边为该表属性的条件下放到ScanPlan中，以减少中间体数目。 投影下移：对于单个表的Scan方案，预先进行一次投影的封装，保留最后选择的属性、用于条件判断和分组的属性，其余属性全部去除，以减少S中间体大小。 连接排序：对于表之间的Join方案，首先通过RmFileHandle来依次读取表中元组数并排序，按照从小到大的顺序决定连接的顺序，以减少中间体数目，并尽可能的下移连接条件。 在决赛中添加的规则有：\n条件替换：如果出现表之间的属性相等条件(A.B = C.D)和其中一个属性的等值条件(C.D = X)，可以去掉等值条件将属性相等条件通过代入法替换成一个等值条件(A.B = X)，从而使本来无法通过索引扫描的表变为索引扫描。 后端 RMDB系统的后端负责实际执行语句，并写入执行结果以供client_handler反送回客户端。\nPortal Portal是接收Plan构建Executor并实际执行语句的中间体，是连接抽象层和实现层之间的桥梁。Portal的接口是：\nstd::shared_ptr\u0026lt;PortalStmt\u0026gt; start(std::shared_ptr\u0026lt;Plan\u0026gt; plan, Context *context, TransactionManager *txn_manager); void run(std::shared_ptr\u0026lt;PortalStmt\u0026gt; portal, QlManager *ql, txn_id_t *txn_id, Context *context); start用于生成根据Plan生成PortalStmt，对于DML语句来说还伴随着Executor的生成。而run函数则执行PortalStmt，根据种类来决定使用哪一个执行模块。大致分为DML、DDL、事务，分别对应ExecutionManager，SmManager，TransactionManager。\n对于DML语句，首先判断语句种类，根据不同的语句构建不同的Executor：\nInsert语句：直接构建InsertExecutor。 Delete/Update语句：根据条件和表名构建SeqScanExecutor/IndexScanExecutor，执行一轮之后按照获取的Rid集合构建DeleteExecutor/UpdateExecutor。 Select语句：照着Plan的结构翻译即可，Select用上的每一种Plan都能找到对应Executor。 对于DDL语句，直接调用SmManager对应的创建/删除/查询函数即可。\n对于事务语句，直接调用TransactionManager的abort，commit函数即可。\nSmManager SmManager是RMDB系统的底层管理器，任何底层操作都要通过SmManger为中介来执行，而任何组件之间的调用都需要SmManager提供指针，任何和表/索引元数据的获取都需要SmManager提供，因此SmManager可以说是数据库的中枢控制器。\nSmManager包含了BufferPoolManager、DiskManager、IndexManager和RmManager。后二者用于对索引和表进行实际的文件操作，而数据库级别的操作由SmManager内部调用命令行语句完成。\nStorage 存储模块主要负责将提供程序运作时的页，并将程序的修改同步到硬盘以持久化。其他模块在运作的时候，是不需要关注存储实现的细节，只需要提出获取页、开闭文件、创建文件的要求，由存储模块实际执行。\nPage Page（页）是磁盘文件最基本的存储单位，表和索引文件都以Page的形式存储并以页的形式进行访问。页本身的序号具有意义，因此无论页处于何处，以何种形式处理，都可以通过唯一的编号PageId来定位。\nPageId指出了是哪一个表（索引）的哪一个Page，可以通过计算式 PAGE_SIZE * PageId.pageno 来方便的定位Page的起点。Page本身不解释其中的内容的含义，只有通过FileHandle进行封装才能执行有意义的页操作。\nDiskManager DiskManager负责开闭文件以及以Page为单位进行读写，使用的是C底层文件流实现以及对系统终端的调用。\nDiskManager的操作是最基本的操作，任何文件相关操作都需要通过调用BufferPoolManager来具体的实现。\n只有绕开BufferPoolManager直接调用disk_manager的情况下不用考虑pin和unpin的问题。\nBufferPoolManager 缓冲池是负责向上层提供具体页并接收指令写回具体页的模块，是对内存中Page进行管理的对象。\n缓冲池可以进行固定页和解绑页，被固定的页不会被纳入替换的列表中。而未被固定的页可以被访问，但是当需要读取新页而缓冲池已满的时候，通过LRU的算法从未被固定的页中选取一份替换，若为脏页则先写回硬盘，而对页的读写操作实际还是由DiskManager执行。\n缓冲池中pin和unpin就像new和delete一样，需要配对。如果缓冲池中所有页面被固定而此时又有对缓冲池中没有的页进行请求，那么这个请求失败，事务回滚。因此，一旦不需要页的内容，就要及时unpin，减少pin_count。new_page和fetch_page两个函数会增加pin_count，只有也只应该有FileHandle调用了这些方法。\nPage* BufferPoolManager::fetch_page(PageId page_id); Page* BufferPoolManager::new_page(PageId* page_id); Pin和Unpin应该由FileHandle成对地封装在接口中以保证没有页泄漏，尽管目前在planner和scan文件中PageHandle被作为返回值供调用者使用，更合理的做法是提供外部接口直接满足其他对象的需求，而不是返回一个PageHandle将Unpin的职责转移给调用方。\nRmManager RmManager是对表文件进行统一管理的对象，负责表文件的创建、销毁、打开和关闭。打开的过程获得一个RmFileHandle，其中包含了RmFileHeader。除了在planner中为了根据元组数量优化连接顺序调用了RmManager的函数，其他时候都是由SmManager对其进行封装并调用，这一点应该上升到强制通过SmManager调用。\nRmFileHandle 文件句柄是对于一个已经打开的文件，能够对其进行读写的中间对象，分为索引句柄和表句柄，RmFileHandle是表句柄。RmFileHandle包含RmFileHeader，其中包含了表的元数据，这些是不可修改的，且存放在表文件的0号页。\nRmFileHandle支持按Rid进行操作如update_record，delete_record，也可以通过页号获取页句柄RmPageHandle。RmPageHandle是对表中的具体页进行管理的对象，通过调用BufferPoolManager接口获取Page并封装。\nRmPageHandle RmPageHandle包含了页的信息以及原始数据，基本上只在遍历的时候用上，使用其中的slot来遍历页并获取下一张页的信息。一般用于遍历或者计算元组数量使用，如果要修改某个页的内容，请通过RmFileHandle提供的接口来进行。\n每一个RmPage分为三个部分RmPageHeader、Slot、Data，分别保存了页的元数据，槽位bitmap，元组数据。\nRmRecord RmRecord是元组在内存中的存在形式，元组本身只有data这一部分，也就是纯粹存储信息的一段紧密01数据，而通过赋予size，allocated信息使得其能够被赋予使用意义并有效管理。但修改一个从RmFileHandle得来的RmRecord对象或者其指针引用并不会将改变写到内存中，因为RmRecord的几乎所有构造方式都是复制数据。\nRmScan RmScan是实际对记录进行扫描的对象，每次获得一个Rid的时候，都会先检查其版本记录，根据最新可见版本是否存在，是否删除决定元组是否可见。\n在判断可见性的过程中如果要回溯的话会首先访问一次版本记录，于是将此次记录先缓存，以免在Next()函数调用时再进行一次回溯。同时改进原本的std::vector存放旧列值，以及哪些列修改的属性，直接存放元组的01内容效率更高。\nIxManager IxManager和RmManager类似，是对索引文件进行底层管理的对象，相比而言增加了一些判断函数用于实际执行中选择索引。\nIxFileHandle IxFileHandle是对于索引文件而言的，支持通过key的方式查询唯一性和调整索引结构。IxFileHandle包含IxFileHeader，其中包含了索引的元数据，这些是不可修改的，且存放在索引文件的0号页。每一个节点存放了若干个键，在叶节点中存放着对应的元组Rid，也是索引实际存放的内容，即按照key的顺序在B+中按树叶节点遍历的位置存放元组的唯一标识。\n除了fetch_node之外的所有未被外部调用的接口都满足Pin和Unpin成对，在别的分支有过修改，将唯一在IxScan中的调用搬到IxFileHandle内部实现，最终满足外部接口不返回IxNodeHandle，缓冲池不泄露。\nIxNodeHandle IxNodeHandle实际上和RmPageHandle一样，包含了页的信息以及原始数据，但是由于索引文件中每一个页都是一个B+树节点，因此得名NodeHandle。IxNodeHandle支持查询和插入删除等功能，修改力度较小。\nIxNodeHandle一样拥有自己的三部分数据：IxPageHeader、keys、rids，分别保存了页的元数据，键，元组的Rid值。\nIxScan IxScan继承自RmScan，IxScan不同的作用就是按照给定的Iid开始和终点遍历叶节点，从而缩小Rid的范围。也就是说，RmScan每次Rid自增的设定由IxScan升级为在索引中查找下一个符合某些条件的Rid，而根据Rid获取元组的功能依旧没有改变，所以可以复用部分代码。\nExecutor LoadData LoadData执行器采用快速读取的方式从csv文件中逐行转化为RmRecord。首先会在主线程中按行读取string并放到一个集合中，每当这个集合内容达到上限时，就分配一个任务，并向RmFileHandle预分配一个界面。读取完所有的行后，会通过多线程来领取并完成给定的任务，实际是将string处理并插入到对应任务的预分配页面中。\n在插入到表文件之后，需要收集每一个索引的每一个键值对，这通过获取RmFileManager的所有Page进行，然后进行排序，调用索引的bulk_load来一个一个索引的加载。使用bulk_load的时候，会先建立素有叶子节点层，然后递归的向上建立节点。\nFastCount FastCount执行器直接从对应表中的文件头中读取一个记录元组数量的变量，然后构建一个RmRecord返回，而在插入和删除的时候负责维护这个值。\nSort Sort执行器先遍历一轮子Executor获取所有元组，然后进行一次Sort，最后一个一个按顺序返回即可。\nAggregation Aggreation执行器在beginTuple中先遍历一轮子Executor获取所有元组，然后按照分组的字段进行分类，最后依次输出。\nProjection Projection执行器直接对于子Executor得到的RmRecord进行部分复制，从而做到减小元组大小，筛选出目标属性。\nInsert Insert执行器先根据传入的变量构建一个Rmrecord，然后直接调用RmFileHandle执行插入，并且当场插入索引。\nSeqScan SeqScan执行器构建了一个RmScan对象，通过其next、end、Next接口来分别步进、判断结束和获取RmRecord，对于获取到的RmRecrod，执行器需要判断其是否符合筛选条件，如果需要上锁，会在扫描到一条符合的元组的时候就对其上锁，考虑到可能要排队，排队的过程中肯定有别的事务修改了元组，因此获取锁之后还需要进行再验证，即再次判断元组是否符合条件。只有在SeqScan是用于收集Update和Delete的Rid时才会设置上锁选项。\n在实际的Tpcc测试中，由于针对语句进行了优化，SeqScan并没有实际被用上。\nIndexScan IndexScan执行器构建了一个IxScan对象，同样通过其进行实际的探查、获取。在构建之前，需要根据使用的索引和条件来生成key的范围，通过两次查询获取起点和终点的Iid并传递给IxScan。其余的过程和SeqScan类似。\n在提交分支之外有一处优化，如果按照索引的属性顺序排列有连续的等值条件或者不等值条件（不等值条件一定是连续的最后一个），那么得到的元组一定满足这些条件，那么不需要再次验证，可以从待验证的条件中删去。\nNestedLoopJoin NestedLoopJoin执行器先遍历一边右孩子，找到满足连接条件的元组拼接并返回，再让左孩子步进，直到左孩子结束。\nLimit Limit执行器通过简单的计数，在遍历完子查询的输出或者达到限制后宣告end来进行数量限制。\nDelete Delete执行器在获取到Rid集合之后，直接构建一个带删除标记的TupleHeader写回对应的Rid元组位置，不当场删除索引。\nUpdate Update执行器在获取到Rid集合之后，直接构建一个完整RmRecord写回到对应的Rid位置，非事务模式下不涉及索引。\nTransaction 时间戳 全局时间戳是一个每次被访问就会+1的变量，在开启一个事务时以及结束一个事务时都会访问全局时间戳，这样可以保证时间轴的运转是一直向前的，不存在时间戳相同引起的复杂判断。同时TransactionManager有两个map：\nstd::unordered_map\u0026lt;timestamp_t, txn_id_t\u0026gt; TransactionManager::commit_map; std::unordered_map\u0026lt;txn_id_t, timestamp_t\u0026gt; TransactionManager::commit_time; 这两个map用于通过相互转换结束时间戳和获取事务ID，结合函数CheckIfCommitted来判断事务的性质。\n持久化UndoLog 每个事务的UndoLog存储的是这个事务修改的元组本来的样貌和时间，当事务完成之后，Transaction对象不再存在，但是UndoLog仍然需要被保存，以供版本链的回溯。利用map：\nstd::unordered_map\u0026lt;txn_id_t, std::vector\u0026lt;UndoLog\u0026gt;\u0026gt; TransactionManager::txn_undos; 可以从内存中读取过去的UndoLog。UndoLog的保存规则是，谁覆盖谁保留原版本。\n从内存卸除过时事务 反向map和UndoLog不能无限的存储，因为内存是有限制的。一个结束事务可以被卸除的充分条件是：\n如果是提交的，在此事务提交之前开始的所有事务都已经结束。之后开启的任何事务访问到的版本一定不会早于此事务修改的，而UndoLog中的版本是更早的版本，故可以删除。所以需要维护一个当前最早开始的事务ID，由于事务开始时间和事务ID大小性一致，在每次提交的时候删除掉当前最早ID之前的所有事务记录。\n如果是中止的，这个事务的所有UndoLog被恢复，所以不存在影响。\n在此维护一个est变量表示最早开始的活跃事务，任何事务未结束的事务的元组ts都大于等于est对应事务的start_ts。在此之前提交的事务的提交信息也可以卸除了。\n判断一个时间戳对应的事务是否提交的判据变为了：commit_map中存在时间戳或者时间戳小于est的start_ts。\nMVCC\u0026amp;Lock TupleHeader TupleHeader是附加在每一个元组属性上的字段，\n无锁读 MVCC的精髓就是无锁读，在快照隔离的情况下，只需要验证时间戳就可以获取可见性。\n有锁写 按照冲突直接abort的要求，如果一个事务先修改了元组T1，而另一个后来的事务也向修改T1，那么会直接abort并会一直发生直到第一个事务结束。也就是说，只有这个事务在第一个事务结束后再开始才能不abort地修改。\n上述存在的问题是：\n重做浪费了很多资源，可能出现了资源抢占的现象 难以把握重做的频率，导致第一个事务结束和第二个事务不冲突的那一次的开始时间之间有间隙 所以考虑加锁，当后来的事务试图修改同一个元组时，需要等待已有的锁释放，之后再次检验加锁的元组是否满足需求，若不满足，则取消更改此元组即可。这里的效果是等效的。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/linux%E6%90%AC%E8%BF%90/rmdbdoc/","summary":"写都写了就发上来罢","title":"数据库系统能力大赛总结文档"},{"content":"标题语法 ","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/%E8%AF%AD%E8%A8%80%E6%90%AC%E8%BF%90/markdownsyntax/","summary":"\u003ch2 id=\"标题语法\"\u003e标题语法\u003c/h2\u003e","title":"Markdown基本语法"},{"content":"基本格式 \\e[0m 清除当前所有应用样式 \\e[1m 设置终端输出样式1 \\e[1;2m 组合终端输出样式1和2\n样式列表 ","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/linux%E6%90%AC%E8%BF%90/colorterminal/","summary":"留档用","title":"彩色终端输出"},{"content":"戳泡泡游戏 maimai w55，无牌子\nArcaea 12.25\nChunithm 15.30\nDJMax V 4b 4700，兴趣来了打一打\n范式起源 132.8，没大氪，歌比较少\n另外，买了Deemo II的白金车票和喵塞克的小伙伴，但是基本上没怎么打过\n总体来说中等水平吧，下不去上不来，还有一个目标就是收集所有PC端的音游。\nJ/ARPG 首先端上来的是如龙系列，为什么想玩是因为maimai中有一首很经典的Outlaws lullaby。然后找到了如龙，打玩0代之后就停不下来了，接着体验了审判之眼，审判之逝。\n然后就是仁王系列，毫无疑问是神史参半的，除了美术和地图设计之外都挺好，剧情会让人产生好奇心从而去了解。\n类银河恶魔城 首推Rabiribi和Tevi，虽然有这样那样的瑕疵，但是完美的画风+弹幕爽。 再推终焉系列，目前出了Lilies和Magnolia，同样我认为画风、音乐和剧情很棒，至于游戏内容，属于及格线边缘徘徊的程度，但还没到大份的程度。\n","permalink":"https://zundadd.github.io/HasekawaMikan.github.io/posts/%E6%9D%82%E8%B0%88/gametalking/","summary":"报菜名时间","title":"成分"}]